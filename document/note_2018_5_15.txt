redisCallback
profile——自定义标签<env>——${env}.properties——resources——filter
@Valid——参照JSR-303、JSR-349规范
@GetMapping——spring4.3开始新增的注解，相当于@RequestMapping(method = RequestMethod.GET)
public方法的重写
@Resource——javax的规范，用于按名称注入
RestTemplate——封装了一些HttpClient的方法
aspectj

工具类
google guava——https://www.cnblogs.com/SummerinShire/p/6054983.html
apache common lang3


淘宝前后端分离解决方案——http://2014.jsconf.cn/slides/herman-taobaoweb/index.html

http://blog.csdn.net/jinbiao520/article/details/9903193

vue快速入门
https://www.cnblogs.com/rik28/p/6024425.html
http://www.jb51.net/article/111658.htm

坑——http://www.iteye.com/topic/1131191



conversionService——FormattingConversionServiceFactoryBean——Converter

namespacehandler学以致用——http://blog.csdn.net/boneix/article/details/73608573

mvvm——https://www.jianshu.com/p/a5f2b2b45618

jackson注解——http://blog.csdn.net/sdyy321/article/details/40298081

javax.validator——group——自定义消息——http://jinnianshilongnian.iteye.com/blog/1733708?page=3


spring父子容器初始化
父子容器在没有特殊配置的情况下都默认为XmlWebApplicationContext
父容器通过ServletContextListen先启动，调用自身的初始化方法initWebApplicationContext和configureAndRefreshWebApplicationContext完成初始化，然后将初始化完成的上下文对象通过ServletContext#setAttribute放置到servletContext，name为WebApplicationContext的类名+'.ROOT'。
子容器通过servlet进行初始化，调用FrameWorkServlet的initServletBean，再经由其调用自身的initWebApplicationContext后，和父容器一样继续调用自身的configureAndRefreshWebApplicationContext，然后经由共同的ServletContext#getAttribute获取父容器的应用上下文，并设置给自身。
其中父子在configureAndRefreshWebApplicationContext中共同调用了AbstractApplicationContext#refresh完成初始化。
其中设置父容器的setParent时，XmlWebApplicationContext中同样无实现此方法，原理同XmlWebApplicationContext#setConfigLocation。

springxml解析

spring入口类ContextLoader#initWebApplicationContext——调用本类#configureAndRefreshWebApplicationContext——调用子类AbstractApplicationContext#refresh——调用本类AbstractApplicationContext#obtainFreshBeanFactory——调用子类AbstractRefreshableApplicationContext#refreshBeanFactory——调用子类XmlWebApplicationContext#loadBeanDefinitions，调用AbstractBeanDefinitionReader#loadBeanDefinitions——调用本类#loadBeanDefinitions——调用本类#loadBeanDefinitions——调用子类XmlBeanDefinitionReader#loadBeanDefinitions——调用本类#loadBeanDefinitions——调用本类#doLoadBeanDefinitions——调用本类#registerBeanDefinitions——调用DefaultBeanDefinitionDocumentReader#registerBeanDefinitions——调用本类#doRegisterBeanDefinitions——调用本类#parseBeanDefinitions，至此正式开始解析每个节点，若为bean标签则调用本类#parseDefaultElement解析，若为其他标签则调用BeanDefinitionParserDelegate#parseCustomElement进行自定义标签的解析，见下文。

BeanDefinitionParserDelegate——解析bean的namespace uri，#parseCustomElement会获取所有xml定义的elementNode并以此获取namespaceUri，若namespaceUri为bean则调用#parseDefaultElement，这个方法最终会调用本类的#parseBeanDefinitionAttributes方法，将该bean标签解析完成，其他则调用#parseCustomElement，然后获取该namespaceUri对应的处理器NamespaceHandler，并调用该对象的parse进行相关配置的初始化NamespaceHandler#init
BeanDefinitionParser——bean namespace的各个子参数解析接口，所有解析器最终都会实现这个接口
NamespaceHandler——命名空间注册处理顶级接口
NamespaceHandlerSupport——实现了NamespaceHandler，同时是各种需要注册的namespace的父类，内部封装了一些通用的逻辑，每个NamespaceHandlerSupport的子类会实现NamespaceHandler的init，注册各个element以及对应的解析类，其实质是调用父类NamespaceHandlerSupport的#registerBeanDefinitionParser将element以string、class的形式保存到其内部的map中。
XmlBeanDefinitionReader——xml配置文件的读取器，#doLoadBeanDefinitions，从Resource中解析出w3c的Document对象，用于之后让每个BeanDefinitionParser进行解析
BeanDefinitionDocumentReader——DefaultBeanDefinitionDocumentReader的接口类
DefaultBeanDefinitionDocumentReader——BeanDefinitionDocumentReader的实现类，#registerBeanDefinitions先取得根节点，即XML文件中的<beans>标签，#parseBeanDefinitions用于从根节点开始逐层解析每个标签
同时，ContextLoader#configureAndRefreshWebApplicationContext会调用子类XmlWebApplicationContext的setConfigLocation将contextParam的contextConfigLocation的配置信息注入到location中。
（这里的调用关系就比较复杂了，首先XmlWebApplicationContext是AbstractRefreshableWebApplicationContext的子类，而AbstractRefreshableWebApplicationContext又实现了ConfigurableWebApplicationContext接口，但是却没有实现其的setConfigLocation方法，因而看起来XmlWebApplicationContext并没有重写setConfigLocation，而实际上setConfigLocation的父类AbstractRefreshableWebApplicationContext的父类AbstractRefreshableConfigApplicationContext已经以公有方法的形式定义并实现了setConfigLocation，这样的情况下也算是XmlWebApplicationContext以及其父类AbstractRefreshableWebApplicationContext已经实现了接口ConfigurableWebApplicationContext的setConfigLocation）
关系如下图：
		（定义了setConfigLocation方法并实现）	（定义了setConfigLocation的规范）
	AbstractRefreshableConfigApplicationContext	ConfigurableWebApplicationContext
						||									||
						||继承								||实现
						||									||
						AbstractRefreshableWebApplicationContext
							（变相重写了setConfigLocation）
										||
										||继承
										||
								XmlWebApplicationContext
所以申明类型为ConfigurableWebApplicationContext，实际类型为XmlWebApplicationContext的应用上下文可以正常调用setConfigLocation而不需要另外实现此方法。


ComponentScanBeanDefinitionParser#parse调用#configureScanner，首先根据是否有use-default-filters属性（默认为true，即会扫描所有带@Component的类），然后调用#createScanner，根据use-default-filters属性判断是否创建注解扫描器（即将@Component添加到includeFilters），然后调用#parseBeanNameGenerator生成bean命名规范器以此进行bean的命名规范控制，最后调用#parseTypeFilters来添加或排除注解类，主要分为两种，include-filter对应includeFilters即需要扫描的注解，exclude-filter对应excludeFilters即需要排除的注解，若要使其生效必须将默认的use-default-filters改为false，即不启用默认配置。根据配置的规则创建了扫描器后，将会用该扫描器#doScan扫描basePackages，调用#findCandidateComponents将basePackages转化为spring可以识别的路径并以set集合的形式读取出来，然后以includeFilters以及excludeFilters进行扫描并调用#registerComponents进行注册，到此整个<context:component-scan/>注解处理完成。

RequestMappingHandlerAdapter——请求映射处理适配器
#afterPropertiesSet，调用#initControllerAdviceCache，用于获取带有ControllerAdvice注解的类，并注册@ModelAttribute以及@InitBinder，用于增强控制器。
#handleInternal，使用模板模式，由父类AbstractHandlerMethodAdapter#handle调用，用于获取请求映射的实体控制器以及具体的方法并执行获取返回值

RequestMapping(http://blog.csdn.net/j080624/article/details/56278461)
RequestMappingHandlerMapping——请求映射处理映射器
#afterPropertiesSet，用于注册绑定每个请求与控制器及方法的关系，该方法会调用父类AbstractHandlerMethodMapping#afterPropertiesSet#initHandlerMethods，扫描mvc容器获取所有bean，然后判断bean是否有@Controller或@RequestMapping注解，若有则迭代该控制器的所有方法，通过MethodIntrospector#selectMethods使用匿名内部类的方式重写MetadataLookup#getMappingForMethod，该方法通过RequestMappingInfo拼接url，最后调用#registerHandlerMethod依次注册方法、url并互相绑定

springmvc——数据绑定——https://www.jianshu.com/p/b2fff5864b11
PropertyEditor——PropertyEditorSupport——属性编辑器
TypeConverter——TypeConverterSupport——类型转换器——TypeConverterDelegate（类型转换委托类——负责具体执行转换的类）
PropertyEditorRegistry——PropertyEditorRegistrySupport——属性编辑注册器

springmvc——数据绑定——https://www.jianshu.com/p/b2fff5864b11
PropertyEditor——属性编辑器的顶级接口
PropertyEditorSupport——属性编辑器支持类，实现了PropertyEditor，封装了通用逻辑，是各个编辑器的父类
PropertyEditorRegistry——属性编辑器注册接口
PropertyEditorRegistrySupport——属性编辑器注册类，实现了PropertyEditorRegistry，封装了通用逻辑，#createDefaultEditors注册了常用类型的属性编辑器，#getDefaultEditor根据类名获取每个类型的默认属性编辑器
TypeConverterSupport——继承自PropertyEditorRegistrySupport，并实现了TypeConverter，用于支持各种对象之间的类型转换，#typeConverterDelegate（TypeConverterDelegate类型转换委托类——负责具体执行转换的类）

PropertyAccessor——属性入口类
AbstractPropertyAccessor——继承自TypeConverterSupport，又实现了PropertyAccessor，可以进行类型转换，也可以将值注入到对应的属性中，#setPropertyValues迭代propertyValues，将每个PropertyValue注入到对应的属性中。

DataBinder——实现PropertyEditorRegistry、TypeConverter的类。支持类型转换，参数验证，数据绑定等功能。
WebDataBinder——DataBinder的子类，主要是针对Web请求的数据绑定，通过AbstractPropertyAccessor
ServletRequestDataBinder——WebDataBinder的子类，由此类完成进行参数绑定，#bind调用父类WebDataBinder#doBind方法，而WebDataBinder将继续调用父类DataBinder#doBind将参数进行绑定

ModelAttributeMethodProcessor——将参数以java对象的形式传入controller的类，是最基本的参数绑定处理器


springmvc自定义数据绑定处理——由PropertyEditorRegistrySupport完成默认的数据绑定器——http://blog.csdn.net/z69183787/article/details/52261289

springmvc参数绑定——http://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html
RequestMappingHandlerAdapter
#getDefaultArgumentResolvers注册默认的参数解析器
#getDefaultReturnValueHandlers注册默认的返回值处理器
RequestResponseBodyMethodProcessor——@RequestBody、@ResponseBody
ServletModelAttributeMethodProcessor——支持对象属性绑定
RequestParamMethodArgumentResolver——@RequestParam——支持简单类型数据绑定
PathVariableMethodArgumentResolver——@PathVariable
由实现了InitializingBean的RequestMappingHandlerAdapter完成初始化，在#afterPropertiesSet中依次放置了argumentResolvers、initBinderArgumentResolvers、returnValueHandlers的处理类，三个resolvers如果没有做特殊配置，则会将默认的解析器放入LinkedList中。

SpringMVC的初始化
在DispatcherServlet的init策略中，一共有九个初始化工作，待续
// TODO

SpringMVC消息转换机制
HttpMessageConverter——消息处理顶级接口所有的消息处理器最终都会直接或间接实现这个接口

HttpInputMessage——消息输入处理接口
HttpOutputMessage——消息输出处理接口
HandlerMethodArgumentResolver——方法参数处理接口——用于将入参绑定到java对象
HandlerMethodReturnValueHandler——返回值处理接口——用于将返回值（java对象）输出到前台
如RequestResponseBodyMethodProcessor即实现了HandlerMethodArgumentResolver，又实现了HandlerMethodReturnValueHandler，即既可以处理@RequestBody的请求（#resolveArgument），又可以处理@ResponseBody的返回值（#handleReturnValue）

HandlerExceptionResolver——异常处理接口——用于处理全局异常


DispatcherServlet

initStrategies——DispatcherServlet初始化方法，由方法名可知用于初始化servlet的策略，粗略可以理解为由其爷爷类HttpServletBean#init调用，然后经其父类FrameworkServlet#initServletBean调用
initHandlerMappings——初始化HandlerMapping（如RequestMappingHandlerMapping）
initHandlerAdapters——初始化HandlerAdapter（如RequestMappingHandlerAdapter）


doDispatcher
#getHandlerAdapter根据HandlerExecutionChain的处理器获取能处理的HandlerAdapter（内部通过#supports方法返回的boolean决定能否处理），然后用获取到的HandlerAdapter#handler进行处理，需要注意的是handler只是一个抽象方法，通常实现类为AbstractHandlerMethodAdapter，其实际上是通过调用内部#handleInternal方法进行处理，而此类的handleInternal也只是个接口，需要调用其子类的RequestMappingHandlerAdapter#handleInternal进行处理，然后调用#invokeHandlerMethod进行参数处理、数据绑定、反射调用controller获取返回值并返回等。具体处理为调用ServletInvocableHandlerMethod#invokeAndHandle进行反射调用，其内部有#invokeForRequest以及HandlerMethodReturnValueHandlerComposite#handleReturnValue两个方法比较重要。具体处理如下。

https://my.oschina.net/lichhao/blog/172562
ServletInvocableHandlerMethod#invokeAndHandle调用两个方法：
invokeForRequest先通过适配器获取处理的controller，然后反射调用controller的方法，获取返回值
	其中#getMethodArgumentValues获取参数列表并绑定到java对象，#doInvoke反射执行controller方法获取返回值
handleReturnValue调用HandlerMethodReturnValueHandlerComposite#handleReturnValue根据controller的返回值以及返回值类型决定具体处理的处理器，然后将返回值写入，若处理器为RequestResponseBodyMethodProcessor，则消息转换过程如下。

springmvc messageConverter——
AnnotationDrivenBeanDefinitionParser#parse调用#getMessageConverters，该方法根据你classpath中存在的jar决定最终需要加载哪些messageConverter，然后根据客户端的accept、服务端的produces（由已注册的消息转换器的canWrite决定）决定当前请求的mediaType，然后循环迭代所有消息转换器判断canWrite决定由哪个messageConverter进行消息转换，最后由该消息转换器调用write方法输出（其中每个消息转换器在初始化的时候都会调用构造方法将自身可以处理的mediaType存入了自身的supportedMediaTypes中，以便在之后的produces的判断中能直接从其自身中获取并添加到局部变量中）——http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html

hibernate-validate注解原理
ServletInvocableHandlerMethod#invokeAndHandle——InvocableHandlerMethod#invokeForRequest #getMethodArgumentValues——HandlerMethodArgumentResolverComposite#resolveArgument——ModelAttributeMethodProcessor#validateIfApplicable
springMVC容器在启动时会根据mvc的validator配置决定是否加载自定义校验器，如果没有配置，则会进行通用校验，即加载OptionalValidatorFactoryBean负责校验，而如果项目中加载了hibernate的校验器，则OptionalValidatorFactoryBean会加载hibernate的校验器到类内部的target中，这样在校验的时候实际上是通过代理模式调用了hibernate的校验逻辑。其中OptionalValidatorFactoryBean本身继承自LocalValidatorFactoryBean，而LocalValidatorFactoryBean是实现了javax.validation.Validator接口，同时也实现了InitializingBean，因而在初始化时，会调用其afterPropertiesSet方法，将hibernate的实现通过set方法设置到成员变量targetValidator中。
每当请求发送过来时，ConfigurableWebBindingInitializer#initBinder会将支持该注解或类的校验器保存起来，以便在接下来的检验中使用。

InitializingBean——接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。

AbstractAutowireCapableBeanFactory#invokeInitMethods调用afterPropertiesSet

@EnableWebMvc——以注解形式启用mvc注解，等同于在配置中申明<mvc:annotation-driven/>

post——参数以键值对形式隐藏在requestbody中

fastdfs——https://www.cnblogs.com/Leo_wl/p/6731647.html

slf4j log4j
http://www.importnew.com/7450.html
http://blog.csdn.net/tanga842428/article/details/52924883
http://itindex.net/detail/48502-log-%E6%97%A5%E5%BF%97-%E6%A1%86%E6%9E%B6

logback启动原理——http://blog.csdn.net/MrZhangXL/article/details/68489565
StaticLoggerBinder

tomcat加载过程
http://www.cnblogs.com/xing901022/p/4574961.html


书籍、源码
https://www.cnblogs.com/rainy-shurun/p/6564407.html

netty——dubbo默认的通信组件
https://www.jianshu.com/p/c5068caab217

vue相关
vuex——https://segmentfault.com/a/1190000007516967#articleHeader3

vue项目
知乎——https://www.zhihu.com/question/37984203
音乐搜索播放应用——https://github.com/Sioxas/vue-music/
重构CnodeJS社区——https://github.com/shuiRong/VueCnodeJS

js相关：
真值假值——在JavaScript中，Truthy(真值)指的是在Boolean上下文中转换后的值为真的值。所有值都是真值，除非它们被定义为 falsy (即， 除了false，0，“”，null，undefined和NaN 外)。——https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy

netty学习
https://www.cnblogs.com/azcode/p/6876882.html
http://wiki.jikexueyuan.com/project/netty-4-user-guide/realize-chat.html
https://www.jianshu.com/p/b9f3f6a16911
netty能做什么——https://www.zhihu.com/question/24322387

单独部署一台文件服务器，以避免将来集群部署应用时，文件路径读取的问题。
Load Balance（负载均衡）与High Available（高可用）

部署相关
http://www.importnew.com/27838.html#comment-639983

jenkins
https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000

string
https://www.zhihu.com/question/57697842

es6
https://www.jianshu.com/p/287e0bb867ae

队列
https://www.cnblogs.com/tadckle/p/3530084.html

类加载
https://blog.csdn.net/chenge_j/article/details/72677766

springboot学习
http://springboot.fun/

spring快速构建项目
http://start.spring.io/

双重检查单例与其缺陷：
https://blog.csdn.net/a_842297171/article/details/79316591
volatile保证可见性、禁止指令重排序
指令重排序是JVM对语句执行的优化，只要语句间没有依赖，那JVM就有权对语句进行优化。
单线程的情况下，指令重排序没有线程安全问题，但是在多线程的情况下，线程的共享变量由于会同时被多个线程读取、修改，因而一个线程在读取共享变量后还未来得及修改时，是可能会被其他线程读取到这个无效的值的，因而多线程情况下，指令重排序存在线程安全问题。
①分配空间给对象
②在空间内创建对象
③将对象赋值给引用对象

ArrayList——https://www.cnblogs.com/ShanHeDiao/p/4402030.html
默认初始长度10，每次扩容1.5倍，10-16-25...，每次添加元素，先判断是否超长度，若超则先扩容，扩容方式为：
int oldCapacity = elementData.length;
int newCapacity = oldCapacity + (oldCapacity >> 1);//新容量扩大到原容量的1.5倍，右移一位相关于原数值除以2。
向ArrayList添加对象时，原对象数目加1如果大于原底层数组长度，则以适当长度新
建一个原数组的拷贝，并修改原数组，指向这个新建数组。原数组自动抛弃（java垃圾回收机制会自动回收）。size则在向数组添加对象，自增1。

LinkedHashMap——https://blog.csdn.net/justloveyou_/article/details/71713781
HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap的元素存取过程基本与HashMap基本类似，只是在细节实现上稍有不同。当然，这是由LinkedHashMap本身的特性所决定的，因为它额外维护了一个双向链表用于保持迭代顺序。此外，LinkedHashMap可以很好的支持LRU算法，笔者在第七节便在LinkedHashMap的基础上实现了一个能够很好支持LRU的结构。

mybatis——https://blog.csdn.net/nmgrd/article/details/54608702
# 与 $——https://blog.csdn.net/wo541075754/article/details/54292751
sql拼接与预编译，$在预编译阶段之前已经被替换成了具体的参数，而#在预编译阶段只是将参数替换成了占位符?，然后经过数据库底层的编译，这时即使再传入' or 1 = 1'之类的参数，数据库也只会当做参数，而不会当做指定来进行处理了。数据库执行sql语句可以理解为按照关键字来编译sql语句，而预编译后数据库肯定就不再重复编译了，所以这时再传什么 AND, OR都只会当成普通字符串来处理。

@Param注解的解析见ParamNameResolver

设计模式——https://www.cnblogs.com/foryang/p/5849402.html
装饰模式与代理模式——https://www.cnblogs.com/jaredlam/archive/2011/11/08/2241089.html
装饰模式着重于控制访问权限，在代理类内部就决定了运行时调用的真实对象，而装饰模式着重于增强业务逻辑，在类外部通过构造方法（或set）方法注入实际的方法调用者。

高并发
https://blog.csdn.net/DreamWeaver_zhou/article/details/78587580
https://www.cnblogs.com/lr393993507/p/5909804.html
高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。

提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。

互联网分层架构中，各层次水平扩展的实践又有所不同：

（1）反向代理层可以通过“DNS轮询”的方式来进行水平扩展；

（2）站点层可以通过nginx来进行水平扩展；

（3）服务层可以通过服务连接池来进行水平扩展；

（4）数据库可以按照数据范围，或者数据哈希的方式来进行水平扩展；

各层实施水平扩展后，能够通过增加服务器数量的方式来提升系统的性能，做到理论上的性能无限。

redis RDB AOF——https://blog.csdn.net/m0_38110132/article/details/76906422

分库分表——https://blog.csdn.net/u011277123/article/details/78358808
我们将常用的（id, name, price, company）字段放在一个表中，而不常用的（）字段放在拓展表中，那我们查询时优先查询常用字段，在有必要时才查询拓展字段。可以有效的提高效率，同时减少字段后我们在一个表中可以容纳的数据数量也提高了。

秒杀业务——https://blog.csdn.net/yd201430320529/article/details/70173178
秒杀业务架构优化之路——http://www.infoq.com/cn/articles/flash-deal-architecture-optimization

高并发请求：
1、客户端拦截：js控制按钮不可用，拦截大部分用户
2、站点层拦截，通过uid以及redis集群，为每个uid的请求设置访问频率

Mybatis插件——https://blog.csdn.net/top_code/article/details/55520948
实现org.apache.ibatis.plugin.Interceptor，使用@Signature指定拦截的类、方法签名

mysql replace into

Spring注解
@Cacheable，@CacheEvict——https://www.cnblogs.com/fashflying/p/6908028.html
@Async——异步方法注解
@DependsOn——告诉容器，本类需要依赖某个类，因而需要在该类初始化完成后再初始化本类
@Lazy

@Import——可引入被{@link Configuration}, {@link ImportSelector}, {@link ImportBeanDefinitionRegistrar}三种类修饰的类

Spring Config注解
@Configuration
@Bean
加载规则注解
@ConditionalOnProperty——havingValue与配置中一致时才实例化
@ConditionalOnBean——仅仅在当前上下文中存在某个对象时，才会实例化一个Bean
@ConditionalOnClass——某个class位于类路径上，才会实例化一个Bean
@ConditionalOnMissingClass——某个class类路径上不存在的时候，才会实例化一个Bean
@ConditionalOnExpression——当表达式为true的时候，才会实例化一个Bean
@ConditionalOnMissingBean——仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean
@ConditionalOnMissingClass——某个class类路径上不存在的时候，才会实例化一个Bean
@ConditionalOnNotWebApplication——不是web应用

AOP注解
@Around，@Pointcut，@Before，@After
@Pointcut(value = "@annotation(com.stylefeng.guns.common.annotion.DataSource)")
@Around("cutService()")

Spring的Ordered顺序

分布式与集群
集群：多个相同的应用部署在多个机器上
分布式：一个应用拆分成多个模块部署在多个机器上

springboot的启动原理

logback的配置详解——http://tengj.top/2017/04/05/springboot7/

java的队列 Queue（LinkedList）——https://www.cnblogs.com/skywang12345/p/3308807.html

spring多数据源（AbstractRoutingDataSource）——https://blog.csdn.net/u012881904/article/details/77449710

DataSourceAutoConfiguration
DataSourceInitializer——初始化数据源，执行sql脚本

springboot自动加载bean原理：
自Condition接口开始，由抽象类SpringBootCondition实现，所有condition都继承自这个抽象类，每个condition都有自己的order，用于在容器初始化过程中，按次序加载各个被注解修饰的bean（存在于spring-boot-autoconfigure-x.x.x.jar中）

分布式事务——https://blog.csdn.net/bjweimengshu/article/details/79607522

SpringBoot内嵌tomcat源码context——EmbeddedWebApplicationContext——https://blog.csdn.net/liaokailin/article/details/52269786
ServerProperties#customize-负责加载tomcat配置的类

设计模式：
1、在无法改变既定类的结构、方法时，可使用访问者模式，以自定义类加载既定类，然后在自定义类中添加逻辑操作既定类，既达到实现效果，又不改变原类。

BeanDefinitionBuilder读取配置文件，通过#addPropertyValue，将配置以键值对的形式添加到其内部的beanDefinition中

SpringAop事务
TransactionAspectSupport#invokeWithinTransaction可通过代理method以及targetClass获取TransactionAttribute（内部存储了该方法的事务隔离、传播性、以及rollback-for），
然后调用InvocationCallback#proceedWithInvocation（实际类型为ReflectiveMethodInvocation），继而调用#invokeJoinpoint后由AopUtils#invokeJoinpointUsingReflection完成对目标service的反射调用。
spring对每个被代理的对象方法在被实际调用前都会先调用org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()，判断是否有拦截链，然后按次序执行拦截链上的方法，都执行完毕后，再反射调用本方法。
（需要注意的是在controller中调用的第一个方法会被代理，之后该方法中的类中的方法再被调用时，不会再被代理，因而在该类的方法执行中不能有异常被捕获，否则事务将失效。eg：除该类以外的方法仍然会被代理，事务依然有效）
（需要注意的是所有以this或省略this调用的方法（包括private方法）均不会被spring代理，在此类方法中若抛出异常，且外部捕获后不处理时，事务将失效）
只有代理对象的方法才会被事务监控，而this是普通对象，不会被spring代理，因而事务也就不会生效了
http://jinnianshilongnian.iteye.com/blog/1487235

https://blog.csdn.net/chjttony/article/details/6321440
org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()根据每个被代理的方法的拦截链决定执行顺序，当拦截链上的每个切面方法都执行完毕时，开始反射执行本方法。
org.springframework.transaction.interceptor.TransactionInterceptor.invoke(MethodInvocation)
org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(Method, Class<?>, InvocationCallback)
org.springframework.transaction.interceptor.new InvocationCallback() {...}.proceedWithInvocation()
org.aopalliance.intercept.Joinpoint.proceed()
org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint()
org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(Object, Method, Object[])
java.lang.reflect.Method.invoke(Object, Object...)执行反射

TransactionAspectSupport#invokeWithinTransaction——invocation.proceedWithInvocation()
（出现异常catch）#completeTransactionAfterThrowing
txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus())
org.springframework.transaction.support.AbstractPlatformTransactionManager.rollback(TransactionStatus)
org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(DefaultTransactionStatus)
org.springframework.jdbc.datasource.DataSourceTransactionManager.doSetRollbackOnly(DefaultTransactionStatus)设置回滚标志，之后在事务commit时会检查该标志，即使异常被捕获，只要发现该标志被修改，事务依然会回滚，具体见：
org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(TransactionStatus)