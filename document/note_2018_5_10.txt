redisCallback
profile——自定义标签<env>——${env}.properties——resources——filter
public方法的重写

RestTemplate——封装了一些HttpClient的方法
aspectj

method——isBridge——jvm泛型参数方法的桥接模式
https://www.cnblogs.com/zsg88/p/7588929.html

SimpleUrlHandlerMapping优先级低于RequestMappingHandlerMapping，所以只有与controller映射失败的请求才有可能进入SimpleUrlHandlerMapping。
同理，HttpRequestHandlerAdapter优先级也低于RequestMappingHandlerAdapter
正常请求：
RequestMappingHandlerMapping——RequestMappingHandlerAdapter——HandlerMethod

<mvc:default-servlet-handler/>——将请求转发给defaultServlet即给容器处理，等同于在web.xml手动配置静态资源到defaultServlet
SimpleUrlHandlerMapping（AbstractUrlHandlerMapping）——HttpRequestHandlerAdapter——DefaultServletHttpRequestHandler
urlMap：key——resourceUrl,value——resourceHandlerName（ResourceHttpRequestHandler#0）

<mvc:resources/>
SimpleUrlHandlerMapping（AbstractUrlHandlerMapping）——HttpRequestHandlerAdapter——ResourceHttpRequestHandler
urlMap：key——resourceUrl,value——resourceHandlerName（ResourceHttpRequestHandler#0）

conversionService——FormattingConversionServiceFactoryBean——Converter
BeanWrapper、DataBinder、ConversionService、Formatter
// 可添加Converter——converters（用于参数的类型转换）以及Formatter——formatters（用于参数的格式转换）
https://segmentfault.com/a/1190000008938863
// TODO
AnnotationFormatterFactory


namespacehandler学以致用——http://blog.csdn.net/boneix/article/details/73608573

jackson注解——http://blog.csdn.net/sdyy321/article/details/40298081

javax.validator——group——自定义消息——http://jinnianshilongnian.iteye.com/blog/1733708?page=3

String常量池——https://www.cnblogs.com/wyfstudy/p/6551458.html


spring父子容器初始化
父子容器在没有特殊配置的情况下都默认为XmlWebApplicationContext
父容器通过ServletContextListen先启动，调用自身的初始化方法initWebApplicationContext和configureAndRefreshWebApplicationContext完成初始化，然后将初始化完成的上下文对象通过ServletContext#setAttribute放置到servletContext，name为WebApplicationContext的类名+'.ROOT'。
子容器通过servlet进行初始化，调用FrameWorkServlet的initServletBean，再经由其调用自身的initWebApplicationContext后，经由#createWebApplicationContext根据父上下文容器实例化子容器，并将父容器设置给子容器，并将返回的子容器作为成员变量设置给FrameworkServlet#webApplicationContext保存。
其中父子在configureAndRefreshWebApplicationContext中共同调用了AbstractApplicationContext#refresh完成初始化。
其中设置父容器的setParent时，XmlWebApplicationContext中同样无实现此方法，原理同XmlWebApplicationContext#setConfigLocation。

springxml解析

spring入口类ContextLoader#initWebApplicationContext
调用本类#configureAndRefreshWebApplicationContext继续配置应用上下文
调用子类AbstractApplicationContext#refresh
调用本类AbstractApplicationContext#obtainFreshBeanFactory获取bean工厂,初始化过程中会获取parentApplicationContext，不为空将父级ApplicationContext#beanFactory通过DefaultListableBeanFactory.DefaultListableBeanFactory(BeanFactory)放入子容器（主要用于spring父子容器-SpringMvc）
调用子类AbstractRefreshableApplicationContext#refreshBeanFactory
调用子类XmlWebApplicationContext#loadBeanDefinitions，继而创建BeanDefinitionReader——XmlBeanDefinitionReader(AbstractBeanDefinitionReader)实例，并将beanFactory注入其内部变量registry中，用以在后续加载xml并封装beanDefinition使用
调用XmlBeanDefinitionReader父类——AbstractBeanDefinitionReader#loadBeanDefinitions继续加载
调用本类#loadBeanDefinitions
调用本类#loadBeanDefinitions
调用子类XmlBeanDefinitionReader#loadBeanDefinitions
调用本类#loadBeanDefinitions
调用本类#doLoadBeanDefinitions，根据resource加载出document文档对象
调用本类#registerBeanDefinitions，创建BeanDefinitionDocumentReader，实为DefaultBeanDefinitionDocumentReader实例，并开始读取document的Element
调用DefaultBeanDefinitionDocumentReader#registerBeanDefinitions——调用本类#doRegisterBeanDefinitions——会判断xml的profile是否符合当前active的profile若不符合，则不会继续加载，否则调用本类#parseBeanDefinitions，至此正式开始解析每个节点，解析完成后，将BeanDefinition注册到本地的ConcurrentHashMap<String, BeanDefinition> beanDefinitionMap中;若为bean标签则调用本类#parseDefaultElement解析，若为其他标签则调用BeanDefinitionParserDelegate#parseCustomElement进行自定义标签的解析，见下文。

BeanDefinitionParserDelegate——解析bean的namespace uri，#parseCustomElement会获取所有xml定义的elementNode并以此获取namespaceUri，若namespaceUri为bean则调用#parseDefaultElement，这个方法最终会调用本类的#parseBeanDefinitionAttributes方法，将该bean标签解析完成，其他则调用#parseCustomElement，然后获取该namespaceUri对应的处理器NamespaceHandler，并进行相关配置的初始化NamespaceHandler#init，然后调用该NamespaceHandler对象的parse，该方法会调用父类NamespaceHandlerSupport的parse先获取已通过init注册到其中的对应BeanDefinitionParser的解析实现类，然后用对用解析类重写的parse方法继续解析。

而基于注解的bean则通过<context:component-scan>经由ComponentScanBeanDefinitionParser#parse，最后通过ClassPathBeanDefinitionScanner#doScan(String basePackages)进行扫描并转化为Set<BeanDefinitionHolder>。
由ReaderContext#fireComponentRegistered统一添加到内部的ReaderEventListener中

在AbstractApplicationContext#invokeBeanFactoryPostProcessors，通过PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors，再调用内部#invokeBeanDefinitionRegistryPostProcessors，通过BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry（实际为ConfigurationClassPostProcessor）进行初始化。（而Mybatis的MapperScannerConfigurer即mapper则通过MapperScannerConfigurer#postProcessBeanDefinitionRegistry进行初始化配置）

AbstractApplicationContext实现了getBean的方法，而其内部的getBeanFactory方法则由子类ConfigurableApplicationContext定义，其实现在AbstractRefreshableApplicationContext，其内部存储了一个DefaultListableBeanFactory的beanfactory。所有的bean最终都由这个beanFactory获取。
虽然都由其获取，但是事实上其内部也就多扩展了两个getBean方法，所以实际上多数的getBean都由其调用父类AbstractBeanFactory的getBean实现，获取过程中最终会调用AbstractBeanFactory#doGetBean，顺序为：
DefaultListableBeanFactory.getBean(String, Class<T>)
DefaultListableBeanFactory调用父类AbstractBeanFactory.getBean(String, Class<T>)
AbstractBeanFactory.doGetBean(String, Class<T>, Object[], boolean)

DefaultListableBeanFactory——用以保存beanDefinition以及beanName，实际的获取singleton在其父类DefaultSingletonBeanRegistry中

private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver();

private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<Class<?>, Object>(16);
以key-requiredBeanClass，value-bean实例或ObjectFactory，维护了所有需要@Autowired、@Resource、@Injected或@Value注入的bean或bean的ObjectFactory
由ConfigurableListableBeanFactory.registerResolvableDependency(Class<?>, Object)统一注册
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>(256);
存储所有beanDefinition，key为beanName，value为beanDefinition
private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);
以key-beanClass，value-beanNames封装了所有bean的type，用以给getBeanNamesForType和getBeansOfType根据类型获取bean或beanNames使用，其在第一次调用时才会put。
private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);
以key-beanClass，value-beanNames封装了所有单例bean的type，用以给getBeanNamesForType和getBeansOfType根据类型获取bean或beanNames使用，其在第一次调用时才会put。

private volatile List<String> beanDefinitionNames = new ArrayList<String>(256);
与beanDefinitionMap同步，只存所有的beanName
private volatile Set<String> manualSingletonNames = new LinkedHashSet<String>(16);


https://blog.csdn.net/hongxingxiaonan/article/details/49835861
SimpleAliasRegistry——别名查找库，实现自AliasRegistry，内部存储了一个Map<String, String>的aliasMap，key为alias（别名），value为beanName（ID）
DefaultSingletonBeanRegistry——id查找库，实现自SingletonBeanRegistry，实际存储单例bean的类，以key、value形式存储
没有ID也没有name的bean会被赋予ID，格式为类的全限定名+数字（从0开始，有一个相同类型的就向上自增）
有ID也有name的，则name为别名
其中不同bean的id与name也不可相同，否则无法判断传入的是id还是name。
会由BeanDefinitionParserDelegate.checkNameUniqueness(String, List<String>, Element)以#usedNames进行检测

AbstractBeanFactory的父类DefaultSingletonBeanRegistry继承了SimpleAliasRegistry并实现SingletonBeanRegistry，使得它既有管理SingletonBean的功能，又提供了别名的功能，它是一个通用的存储共享bean实例的地方。在注册一个SingletonBean的时候，用到了四个存储器：
singletonObjects：用来存放注册的SingletonBean，具体的实现类是ConcurrentHashMap。
singletonFactories：存储制造 singleton 的工厂。
earlySingletonObjects：是singletonFactory 制造出来的 singleton 的缓存。
registeredSingletons：按顺序存放已经注册的SingletonBean的名称。
在 getSingleton的时候，spring的默认实现是，先从singletonObjects寻找，如果找不到，再从earlySingletonObjects寻找，仍然找不到，那就从singletonFactories寻找对应的制造singleton的工厂，然后调用工厂的getObject方法（在getBean方法中，可以看到方法走到此处，缓存中没拿到对象，这里实质就是通过内部类的方法调用AbstractAutowireCapableBeanFactory.createBean(String, RootBeanDefinition, Object[])重新构建bean对象），造出对应的SingletonBean，并放入earlySingletonObjects中。具体见DefaultSingletonBeanRegistry.getSingleton
DefaultSingletonBeanRegistry.dependentBeanMap以key-beanName，value-dependentBean存储每个bean的依赖bean
Set<String> singletonsCurrentlyInCreation：存储正在创建中的beanName，可用于解决循环依赖的问题。

// TODO
private final Map<String, Object> disposableBeans = new LinkedHashMap<String, Object>();
private final Map<String, Set<String>> containedBeanMap = new ConcurrentHashMap<String, Set<String>>(16);
private final Map<String, Set<String>> dependentBeanMap = new ConcurrentHashMap<String, Set<String>>(64);
bean依赖关系维护的map，key-beanName，value-依赖该key的beanName，由DefaultSingletonBeanRegistry.registerDependentBean(String, String)注册
private final Map<String, Set<String>> dependenciesForBeanMap = new ConcurrentHashMap<String, Set<String>>(64);
bean依赖关系维护的map，key-value与dependentBeanMap正好相反，key-beanName，value-该key依赖的beanName，，由DefaultSingletonBeanRegistry.registerDependentBean(String, String)注册

BeanDefinitionRegistry从容器操作BeanDefinition的一个接口，其主要的两个实现DefaultListableBeanFactory、GenericApplicationContext，#registerBeanDefinition，根据beanName判断容器内是否已有相同key的BeanDefinition，若不存在或允许覆盖即isAllowBeanDefinitionOverriding为true时正常解析，否则抛出异常，注册完成后，将BeanDefinition添加到内部的ConcurrentHashMap<String, BeanDefinition> beanDefinitionMap中，同时将beanName添加到beanDefinitionNames中。

// TODO
PropertyPlaceholderConfigurer
PropertyResourceConfigurer实现了BeanFactoryPostProcessor，#postProcessBeanFactory调用内部#processProperties，PlaceholderConfigurerSupport#doProcessProperties，其内部先获取每个bean，而后以访问者方式，并以*.properties的值填充xml中的占位符。(TODO)

org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor继承自org.springframework.beans.factory.config.BeanFactoryPostProcessor，mybatis的MapperScannerConfigurer和spring处理@Configuration的ConfigurationClassPostProcessor就是实现自此接口

/********************待定********************/
而基于注解的bean则通过AnnotationConfigWebApplicationContext#loadBeanDefinitions，通过ClassPathBeanDefinitionScanner#scan，将指定包路径下的bean扫描到容器。
/********************待定********************/


BeanDefinitionParser——bean namespace的各个子参数解析接口，所有解析器最终都会实现这个接口
NamespaceHandler——命名空间注册处理顶级接口
NamespaceHandlerSupport——实现了NamespaceHandler，同时是各种需要注册的namespace的父类，内部封装了一些通用的逻辑，每个NamespaceHandlerSupport的子类会实现NamespaceHandler的init，注册各个element以及对应的解析类，其实质是调用父类NamespaceHandlerSupport的#registerBeanDefinitionParser将element以string、class的形式保存到其内部的map#parsers中。

DefaultNamespaceHandlerResolver.resolve(String)根据入参namespaceUri获取对应的NamespaceHandler，然后调用#init注册内部的parser，最后以key-namespaceUri，value-NamespaceHandler形式放入内部的缓存handlerMappings中。

XmlBeanDefinitionReader——xml配置文件的读取器，#doLoadBeanDefinitions，从Resource中解析出w3c的Document对象，用于之后让每个BeanDefinitionParser进行解析
BeanDefinitionDocumentReader——DefaultBeanDefinitionDocumentReader的接口类
DefaultBeanDefinitionDocumentReader——BeanDefinitionDocumentReader的实现类，#registerBeanDefinitions先取得根节点，即XML文件中的<beans>标签，#parseBeanDefinitions用于从根节点开始逐层解析每个标签
同时，ContextLoader#configureAndRefreshWebApplicationContext会调用子类XmlWebApplicationContext的setConfigLocation将contextParam的contextConfigLocation的配置信息注入到location中。
（这里的调用关系就比较复杂了，首先XmlWebApplicationContext是AbstractRefreshableWebApplicationContext的子类，而AbstractRefreshableWebApplicationContext又实现了ConfigurableWebApplicationContext接口，但是却没有实现其的setConfigLocation方法，因而看起来XmlWebApplicationContext并没有重写setConfigLocation，而实际上setConfigLocation的父类AbstractRefreshableWebApplicationContext的父类AbstractRefreshableConfigApplicationContext已经以公有方法的形式定义并实现了setConfigLocation，这样的情况下也算是XmlWebApplicationContext以及其父类AbstractRefreshableWebApplicationContext已经实现了接口ConfigurableWebApplicationContext的setConfigLocation）
关系如下图：
		（定义了setConfigLocation方法并实现）	（定义了setConfigLocation的规范）
	AbstractRefreshableConfigApplicationContext	ConfigurableWebApplicationContext
						||									||
						||继承								||实现
						||									||
						AbstractRefreshableWebApplicationContext
							（变相重写了setConfigLocation）
										||
										||继承
										||
								XmlWebApplicationContext
所以申明类型为ConfigurableWebApplicationContext，实际类型为XmlWebApplicationContext的应用上下文可以正常调用setConfigLocation而不需要另外实现此方法。


ComponentScanBeanDefinitionParser#parse调用#configureScanner，首先根据是否有use-default-filters属性（默认为true，即会扫描所有带@Component的类），然后调用#createScanner，根据use-default-filters属性判断是否创建注解扫描器（即将@Component添加到includeFilters），然后调用#parseBeanNameGenerator生成bean命名规范器以此进行bean的命名规范控制，最后调用#parseTypeFilters来添加或排除注解类，主要分为两种，include-filter对应includeFilters即需要扫描的注解，exclude-filter对应excludeFilters即需要排除的注解，若要使其生效必须将默认的use-default-filters改为false，即不启用默认配置。根据配置的规则创建了扫描器后，将会用该扫描器#doScan扫描basePackages，调用#findCandidateComponents将basePackages转化为spring可以识别的路径并以set集合的形式读取出来，然后以includeFilters以及excludeFilters进行扫描并调用#registerComponents进行注册，到此整个<context:component-scan/>注解处理完成。

几个关键的判断：
（1）ClassPathScanningCandidateComponentProvider.isCandidateComponent(MetadataReader)
判断当前resource的class是否需要继续加入容器，如是否带有@Profile注解，该值是否符合当前激活的profile，等等// TODO
其实质也是判断内部是否有@Conditional注解

（2）ClassPathScanningCandidateComponentProvider.isCandidateComponent(AnnotatedBeanDefinition)
通过入参获取AnnotationMetadata metadata = beanDefinition.getMetadata();
然后通过metadata判断该beanDefinition即ScannedGenericBeanDefinition（BeanDefinition）是否为抽象的、或接口，若非具体的bean，则最终不会加入返回的Set<BeanDefinition>——candidates中
注：若该bean中有方法带有@Lookup注解时，即便是抽象类也会被cglib生成代理实例。同时被@Lookup修饰的方法会优先根据@Lookup的value为beanName获取bean，若value为空，则通过@Lookup方法的returnValue获取bean。因而可通过这种方式，将抽象类注册为bean，并用抽象方法结合@Lookup注解，可在方法内部获取bean。


springmvc——数据绑定——https://www.jianshu.com/p/b2fff5864b11
PropertyEditor——PropertyEditorSupport——属性编辑器
TypeConverter——TypeConverterSupport——类型转换器——TypeConverterDelegate（类型转换委托类——负责具体执行转换的类）
PropertyEditorRegistry——PropertyEditorRegistrySupport——属性编辑注册器

springmvc——数据绑定——https://www.jianshu.com/p/b2fff5864b11
PropertyEditor——属性编辑器的顶级接口
PropertyEditorSupport——属性编辑器支持类，实现了PropertyEditor，封装了通用逻辑，是各个编辑器的父类
PropertyEditorRegistry——属性编辑器注册接口
PropertyEditorRegistrySupport——属性编辑器注册类，实现了PropertyEditorRegistry，封装了通用逻辑，#createDefaultEditors注册了常用类型的属性编辑器，#getDefaultEditor根据类名获取每个类型的默认属性编辑器
TypeConverterSupport——继承自PropertyEditorRegistrySupport，并实现了TypeConverter，用于支持各种对象之间的类型转换，#typeConverterDelegate（TypeConverterDelegate类型转换委托类——负责具体执行转换的类）

PropertyAccessor——属性入口类
AbstractPropertyAccessor——继承自TypeConverterSupport，又实现了PropertyAccessor，可以进行类型转换，也可以将值注入到对应的属性中，#setPropertyValues迭代propertyValues，将每个PropertyValue注入到对应的属性中。

DataBinder——实现PropertyEditorRegistry、TypeConverter的类。支持类型转换，参数验证，数据绑定等功能。
WebDataBinder——DataBinder的子类，主要是针对Web请求的数据绑定，通过AbstractPropertyAccessor
ServletRequestDataBinder——WebDataBinder的子类，由此类完成进行参数绑定，#bind调用父类WebDataBinder#doBind方法，而WebDataBinder将继续调用父类DataBinder#doBind将参数进行绑定（其内部实为通过BeanWrapper进行绑定）
其内部有conversionService（用于类型转换）、validators（用于验证）、typeConverter（用于注册属性编辑器）等参数。

BeanWrapper（ConfigurablePropertyAccessor->PropertyAccessor、PropertyEditorRegistry、TypeConverter）
bean实例的包装类。由BeanWrapperImpl（AbstractNestablePropertyAccessor->AbstractPropertyAccessor->TypeConverterSupport->PropertyEditorRegistrySupport负责注册各种组件，DataBinder的许多注册方法就是调用其完成的）实现

AbstractNestablePropertyAccessor#wrappedObject为bean实例
其可通过以下两种方式设置参数：
AbstractNestablePropertyAccessor.setPropertyValue(PropertyValue)——PropertyValue为参数键值对（name与value）（PropertyValues中存储的就是该类型）
AbstractNestablePropertyAccessor.setPropertyValue(String, Object)——String为参数名，Object为参数值
AbstractPropertyAccessor.setPropertyValues(PropertyValues, boolean, boolean)-将PropertyValues迭代并逐个赋值
// TODO
参数绑定过程大致为：
DataBinder#doBind->PropertyAccessor#setPropertyValues->AbstractNestablePropertyAccessor#convertIfNecessary->TypeConverterDelegate#convertIfNecessary->PropertyEditorRegistrySupport#getConversionService->ConversionService#convert(Object, TypeDescriptor, TypeDescriptor)

ModelAttributeMethodProcessor——将参数以java对象的形式传入controller的类，是最基本的参数绑定处理器

RequestMappingHandlerAdapter——请求映射处理适配器
#afterPropertiesSet，
1、调用#initControllerAdviceCache，用于获取带有ControllerAdvice注解的类，并注册@ModelAttribute以及@InitBinder，用于增强控制器。
	（1）调用ControllerAdviceBean.findAnnotatedBeans(ApplicationContext)，其内部会从容器中获取所有类，而后将含有@ControllerAdvice的类封装成ControllerAdviceBean对象，并添加到list中并返回。
	（2）调用AnnotationAwareOrderComparator.sort(List<?>)将（1）中的list——beans排序
	（3）调用MethodIntrospector.selectMethods(Class<?>, MethodFilter)——（beanType，MODEL_ATTRIBUTE_METHODS）逐个从beans中获取带@ModelAttribute，且不带@RequestMapping注解的Method，并添加到modelAttributeAdviceCache（key-ControllerAdviceBean，value-Set<Method>）中
	（4）调用MethodIntrospector.selectMethods(Class<?>, MethodFilter)——（beanType，INIT_BINDER_METHODS）逐个从beans中获取带@InitBinder注解的Method，并添加到initBinderAdviceCache（key-ControllerAdviceBean，value-Set<Method>）中
	（5）调用java.lang.Class.isAssignableFrom(Class<?>)从beans中找出实现了RequestBodyAdvice的bean
	（6）调用java.lang.Class.isAssignableFrom(Class<?>)从beans中找出实现了ResponseBodyAdvice的bean
	（7）将（5）、（6）的返回值添加到requestResponseBodyAdvice中。

同样的，在ExceptionHandlerExceptionResolver中
通过#afterPropertiesSet，也会调用initExceptionHandlerAdviceCache获取带有ControllerAdvice注解的类，查找含@ExceptionHandler的方法，保存到exceptionHandlerAdviceCache中，用于通用的异常处理。
// TODO

2、调用RequestMappingHandlerAdapter.getDefaultArgumentResolvers()，而后创建HandlerMethodArgumentResolverComposite实例并将上一方法的返回值添加到HandlerMethodArgumentResolverComposite.argumentResolvers中，并指向argumentResolvers。
3、调用RequestMappingHandlerAdapter.getDefaultInitBinderArgumentResolvers()，而后创建HandlerMethodArgumentResolverComposite实例并将上一方法的返回值添加到HandlerMethodArgumentResolverComposite.argumentResolvers中，并指向initBinderArgumentResolvers。
4、调用RequestMappingHandlerAdapter.getDefaultReturnValueHandlers()，而后创建HandlerMethodArgumentResolverComposite实例并将上一方法的返回值添加到HandlerMethodArgumentResolverComposite.returnValueHandlers中，并指向returnValueHandlers。

#handleInternal，使用模板模式，由父类AbstractHandlerMethodAdapter#handle调用，用于获取请求映射的实体控制器以及具体的方法并执行获取返回值

RequestMapping(http://blog.csdn.net/j080624/article/details/56278461)
RequestMappingHandlerMapping——请求映射处理映射器
#afterPropertiesSet，用于注册绑定每个请求与控制器及方法的关系，该方法会调用父类AbstractHandlerMethodMapping#afterPropertiesSet#initHandlerMethods，扫描mvc容器获取所有bean，然后根据#isHandler判断bean是否有@Controller或@RequestMapping注解（此处的isHandler是接口，具体实现在RequestMappingHandlerMapping中）若有则迭代该控制器的所有方法，通过MethodIntrospector#selectMethods使用匿名内部类的方式重写MetadataLookup#getMappingForMethod，该方法通过RequestMappingInfo拼接url，最后调用#registerHandlerMethod依次注册方法、url并互相绑定
SimpleUrlHandlerMapping——静态绑定映射器，可在xml中直接配置url与controller的绑定关系

springmvc自定义数据绑定处理——由PropertyEditorRegistrySupport完成默认的数据绑定器——http://blog.csdn.net/z69183787/article/details/52261289

springmvc参数绑定——http://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html
RequestMappingHandlerAdapter
#getDefaultArgumentResolvers注册默认的参数解析器
#getDefaultReturnValueHandlers注册默认的返回值处理器
RequestResponseBodyMethodProcessor——@RequestBody、@ResponseBody
ServletModelAttributeMethodProcessor——继承自ModelAttributeMethodProcessor支持对象属性绑定，由其父类的supportsParameter可知，其支持@ModelAttribute注解的变量以及所有非简单类型的对象，即!BeanUtils.isSimpleProperty(Class<?>)为true时才会使用该类作为参数解析器，除此之外，该解析器还支持@Valid注解，对对象进行校验。
HandlerMethodArgumentResolver——RequestParamMethodArgumentResolver、PathVariableMethodArgumentResolver的父类，通过#resolveArgument解析参数值，并通过创建WebDataBinder，以DataBinder.convertIfNecessary(Object, Class<?>, MethodParameter)将参数值根据参数类型（MethodParameter）绑定到对应的参数上。
RequestParamMethodArgumentResolver——@RequestParam——支持简单类型数据绑定
PathVariableMethodArgumentResolver——@PathVariable
由实现了InitializingBean的RequestMappingHandlerAdapter完成初始化，在#afterPropertiesSet中依次放置了argumentResolvers、initBinderArgumentResolvers、returnValueHandlers的处理类集合，三个resolvers如果没有做特殊配置，则只会将默认的解析器放入argumentResolvers、initBinderArgumentResolvers、returnValueHandlers中。

resolveArgument——参数处理接口
在doDispatcher调用RequestMappingHandlerAdapter#invokeHandlerMethod时会将这几个处理集合赋值给局部变量ServletInvocableHandlerMethod实例的两个Composite：argumentResolvers、returnValueHandlers（这两个变量定义在其父类InvocableHandlerMethod中），并在#getMethodArgumentValues中通过该Composite#supportsParameter判断是否支持该类参数的处理，若支持，则继续调用HandlerMethodArgumentResolverComposite#resolveArgument获取对应的argumentResolver，并调用其#resolveArgument完成参数解析。

returnValueHandlers——返回值处理接口
// TODO

SpringMVC的初始化
在DispatcherServlet的init策略中，一共有九个初始化工作，待续
// TODO

SpringMVC消息转换机制
HttpMessageConverter——消息处理顶级接口所有的消息处理器最终都会直接或间接实现这个接口

HttpInputMessage——消息输入处理接口，作为HttpMessageConverter#read入参传入
HttpOutputMessage——消息输出处理接口，作为HttpMessageConverter#write入参传入
HandlerMethodArgumentResolver——方法参数处理接口——用于将入参绑定到java对象
HandlerMethodReturnValueHandler——返回值处理接口——用于将返回值（java对象）输出到前台
如RequestResponseBodyMethodProcessor即实现了HandlerMethodArgumentResolver，又实现了HandlerMethodReturnValueHandler，即既可以处理@RequestBody的请求（#resolveArgument），又可以处理@ResponseBody的返回值（#handleReturnValue）

HandlerExceptionResolver——异常处理接口——用于处理全局异常

SpringMVC输入输出参数的一些设计思路

AnnotationDrivenBeanDefinitionParser：该类作为mvc容器的核心解析器，主要注册了RequestMappingHandlerMapping和RequestMappingHandlerAdapter两个mvc核心bean。
RequestMappingHandlerMapping：负责mvc容器请求url与实际控制器绑定的类，在初始化中，包含对@Controller、@RequestMapping类和方法的处理，将类级别的requestMapping与方法级别的requestMapping以RequestMappingInfo#combine进行合并。（具体的拼接规则可见org.springframework.util.AntPathMatcher.concat(String, String)，实际不管父类与方法的requestUrl带不带"/"，最终都会正常拼接）
RequestMappingHandlerAdapter：负责参数解析和返回值处理即argumentResolver和returnValueHandler，在初始化中，包括对@ControllerAdvice的初始化、@ModelAttribute（且不含RequestMapping）的初始化，以及argumentResolver、initBinderArgumentResolvers、returnValueHandlers三个接口处理类的初始化。

argumentResolver——统一实现HandlerMethodArgumentResolver接口，以一个ConcurrentHashMap<MethodParameter, HandlerMethodArgumentResolver>——argumentResolverCache作为缓存，每次先以MethodParameter从缓存中获取，获取到了直接返回，获取不到则迭代已经初始化完毕的argumentResolvers，以其HandlerMethodArgumentResolver#supportsParameter来逐个判断该resolver能否处理当前参数，若可以，则将该resolver和parameter放入缓存map，并返回该resolver，并调用其实现的resolveArgument处理参数。
returnValueHandler——统一实现HandlerMethodReturnValueHandler接口
这两个接口都在AnnotationDrivenBeanDefinitionParser#parse中完成注册，在各自的afterPropertiesSet中完成初始化。

除此之外，AnnotationDrivenBeanDefinitionParser还有以下作用：
1、添加了ExceptionHandlerExceptionResolver，该类是用于初始化和处理@ExceptionHandler注解的方法的。
2、若mvc容器中没有配置conversion-service时，会初始化一个FormattingConversionServiceFactoryBean到容器中。该bean同时实现了InitializingBean与FactoryBean，因而其afterPropertiesSet会进行初始化，而其getObject会生成FormattingConversionService。
在其初始化方法afterPropertiesSet中，通过DefaultFormattingConversionService的构造方法，会调用DefaultConversionService.addDefaultConverters(ConverterRegistry)加入默认的一些类型转换方法，以及DefaultConversionService.addDefaultFormatters加入默认的格式转换方法。

/*****************************************************************************************/

DispatcherServlet初始化策略

initStrategies——DispatcherServlet初始化方法，由方法名可知用于初始化servlet的策略，粗略可以理解为由其爷爷类HttpServletBean#init调用，然后经其父类FrameworkServlet#initServletBean调用。

initMultipartResolver(context);springmvc上传组件，以DispatcherServlet#MULTIPART_RESOLVER_BEAN_NAME即multipartResolver为beanName加载multipartResolver并放置到成员变量中。

initLocaleResolver(context);

initThemeResolver(context);

initHandlerMappings(context);——初始化HandlerMapping，用于在请求来临时获取HandlerExecutionChain

initHandlerAdapters(context);——初始化HandlerAdapter，获取所有HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler，并以AnnotationAwareOrderComparator#sort对解析类进行排序，排序规则为根据order值的大小，越小的优先级越高，而order值可以通过多种方法进行设置（实现Order接口、@Order注解），可见AnnotationAwareOrderComparator#findOrder

initHandlerExceptionResolvers(context);初始化异常处理解析器HandlerExceptionResolver，如ExceptionHandlerExceptionResolver

initRequestToViewNameTranslator(context);

initViewResolvers(context);——初始化视图解析器ViewResolver，如jsp解析器InternalResourceViewResolver、freemarker解析器FreeMarkerViewResolver等。

initFlashMapManager(context);

需要注意的是，上述初始化中，除MultipartResolver外，若没有加载到任何类时，则会调用#getDefaultStrategy读取同路径下的DispatcherServlet.properties，以每个模块的接口名如org.springframework.web.servlet.ViewResolver为key，获取默认的加载类，并保存到成员变量中。


FrameworkServlet#processRequest
	LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
	LocaleContext localeContext = buildLocaleContext(request);
	1、封装一个原先的LocaleContext和当前的LocaleContext，一般而言，原先的LocaleContext为null
	RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
	ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);
	2、封装一个原先的RequestAttributes，一般为null，并调用buildRequestAttributes将当前请求的request、response构建一个ServletRequestAttributes，其内部也只是调用构造实例化一个ServletRequestAttributes而已。
	3、调用FrameworkServlet.initContextHolders(HttpServletRequest, LocaleContext, RequestAttributes)使用LocaleContextHolder、RequestContextHolder两个holder存储上述两步的线程变量localeContext、requestAttributes。
	4、调用子类的DispatcherServlet#doService
	5、调用FrameworkServlet.resetContextHolders(HttpServletRequest, LocaleContext, RequestAttributes)，以原先的previousAttributes、previousAttributes为依据，若为空，则清理对应的holder，防止内存泄漏。
	6、FrameworkServlet.publishRequestHandledEvent(HttpServletRequest, HttpServletResponse, long, Throwable)
	// TODO

DispatcherServlet#doService
保存一些请求级别的变量如applicationContext、localeResolver、themeResolver、themeSource等到请求中，保存的参数都可以由RequestContextUtils根据请求获取。
// TODO

DispatcherServlet#doDispatcher分发请求的核心步骤（此方法做分发，在本类的doService中被调用，而后者则是直接在其父类的FrameworkServlet#processRequest中被调用）

1、checkMultipart(request);
根据是否注入multipartResolver以及MultipartResolver#isMultipart(request)决定是否调用上传组件。其实质为判断request的method是否为post，且其的contentType是否以org.apache.commons.fileupload.FileUploadBase.MULTIPART即"multipart/"开头。

2、mappedHandler = getHandler(processedRequest);
根据request从handlerMappings中获取对应的HandlerMapping，并根据该handlerMapping获取到对应的HandlerExecutionChain并返回（AbstractHandlerMapping#getHandler(HttpServletRequest)），这个过程主要分两步，
	（1）、将请求关联到具体的controller的具体方法（多由子类AbstractHandlerMethodMapping#getHandlerInternal(HttpServletRequest)实现）。具体为根据request获取请求地址，并根据请求地址获取List<RequestMappingInfo>（封装了methodsCondition-RequestMethod以及patternsCondition-requestUrl，实则在初始化时就会以key-url，value-RequestMappingInfo的形式存储在MappingRegistry#urlLookup中，同时还会以key-RequestMappingInfo，value-HandlerMethod的形式存储于AbstractHandlerMethodMapping.MappingRegistry.mappingLookup中，故这里只是单纯的get，具体可见AbstractHandlerMethodMapping.registerMapping）转换成AbstractHandlerMethodMapping.Match<T>并排序（SpringMvc自定义比较器MatchComparator），再从中获取最适合的Match即bestMatch并返回bestMatch.handlerMethod即HandlerMethod（主要是针对一些直接get获取不到的url，如带{variable}的url），该返回的handlerMethod会作为入参实例化HandlerExecutionChain并作为其handler，如此一来在接下来获取HandlerAdapter的过程中，只有RequestMappingHandlerAdapter可以被获取了。

	注：当url为含正则的校验时（即PathVariable时），在AbstractHandlerMethodMapping.lookupHandlerMethod(String, HttpServletRequest)中，
	this.mappingRegistry.getMappingsByUrl(lookupPath);就获取不到RequestMappingInfo了，因而需要继续执行AbstractHandlerMethodMapping.addMatchingMappings(Collection<T>, List<Match>, HttpServletRequest)后，在AbstractHandlerMethodMapping.getMatchingMapping(T, HttpServletRequest)进行match匹配，之后的逻辑和别的相同了。
	在getHandlerInternal的最后会调用通过lookupHandlerMethod获取的HandlerMethod#createWithResolvedBean，其会通过HandlerMethod#bean获取beanName，然后通过beanName以内部的beanFactory#getBean获取controller的bean实例，最后通过HandlerMethod.HandlerMethod(HandlerMethod, Object)构造HandlerMethod并返回，controllerBean就以HandlerMethod#handler形式保存在HandlerMethod中了。

	（2）、根据获得的Object类型（多为HandlerMethod）的handler是否可以转换为HandlerExecutionChain，若可以则直接作为返回值返回，若不可以则以该handler作为构造参数重新实例化该HandlerExecutionChain（AbstractHandlerMapping#getHandlerExecutionChain(Object, HttpServletRequest)），而后以所有拦截器逐个根据入参request的请求地址进行匹配，匹配成功则加入到该HandlerExecutionChain实例的#interceptorList中。

3、DispatcherServlet.noHandlerFound(HttpServletRequest, HttpServletResponse)
若2中返回的mappedHandler为空或mappedHandler#getHandler为空时，调用此方法，告知无请求匹配，结束请求。

4、HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
根据HandlerExecutionChain的处理器从handlerAdapters中获取能处理的HandlerAdapter（内部通过#supports方法返回的boolean决定能否处理）。
主要的适配器有RequestMappingHandlerAdapter（handler为HandlerMethod）、HttpRequestHandlerAdapter（handler为HttpRequestHandler）、SimpleControllerHandlerAdapter（handler为Controller），主要是根据入参的handler类型决定由哪个适配器适配。


getHandler中调用getHandlerExecutionChain，获取请求url然后将内部的所有拦截器包装类逐个match lookupPath，匹配成功就调用HandlerExecutionChain.addInterceptor(HandlerInterceptor)将其放入内部的拦截器集合interceptorList中以供之后拦截请求。

5、mappedHandler.applyPreHandle(processedRequest, response)
HandlerExecutionChain.applyPreHandle(HttpServletRequest, HttpServletResponse)获取HandlerExecutionChain#adaptedInterceptors即内部的interceptors数组，并逐个前置处理方法，若有一个返回false，则在外部的doDispatcher就会被return了，方法执行结束，不会继续反射调用controller的方法了
同时在HandlerAdapter.handle(HttpServletRequest, HttpServletResponse, Object)执行完毕后，还会再调用其HandlerExecutionChain.applyPostHandle(HttpServletRequest, HttpServletResponse, ModelAndView)方法，完成拦截器的后置处理。

关于拦截器<mvc:interceptor/>
每个Interceptor都会被封装成同样实现了HandlerInterceptor接口的MappedInterceptor，该类为final类，内部定义了两个String数组includePatterns和excludePatterns同时还有一个HandlerInterceptor的interceptor，其实这就是最后实际自定义注入的interceptor，其内部都是通过代理用户自定义的interceptor实现拦截器的功能的。内部还有一个PathMatcher的pathMatcher用以对includePatterns和excludePatterns进行match操作。
这么进行代理的好处在于，在获取拦截器链HandlerExecutionChain的方法AbstractHandlerMapping.getHandlerExecutionChain(Object, HttpServletRequest)中，在没有修改用户自定义的拦截器的情况下，通过org.springframework.web.servlet.handler.MappedInterceptor.matches(String, PathMatcher)方法对include和exclude进行匹配删减，以决定是否需要调用拦截器。

PathMatcher
// TODO

6、mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
springmvc真正反射调用controller并返回的核心方法。
根据到的HandlerAdapter进行处理，需要注意的是handler只是一个抽象方法，通常实现类为AbstractHandlerMethodAdapter，其实际上是通过调用内部#handleInternal方法进行处理，而此类的handleInternal也只是个接口，需要调用其子类的RequestMappingHandlerAdapter#handleInternal进行处理，然后调用#invokeHandlerMethod进行参数处理、数据绑定、反射调用controller获取返回值并返回等。
	该方法的主要目的为：
	（1）封装ServletInvocableHandlerMethod（继承自InvocableHandlerMethod），将许多对象封装于其中：
	关于ServletInvocableHandlerMethod
	ServletInvocableHandlerMethod——HandlerMethodArgumentResolverComposite argumentResolvers，内部存储了List<HandlerMethodArgumentResolver>，用于解析参数。
	InvocableHandlerMethod——HandlerMethodReturnValueHandlerComposite returnValueHandlers，内部存储了List<HandlerMethodReturnValueHandler> returnValueHandlers，用于封装返回值。
	InvocableHandlerMethod——WebDataBinderFactory dataBinderFactory——用于绑定参数，包括之后对@InitBinder的自定义绑定器的反射调用。
	InvocableHandlerMethod——ParameterNameDiscoverer parameterNameDiscoverer
	（2）封装ModelAndViewContainer
	（3）封装AsyncWebRequest
	（4）封装WebAsyncManager
	（5）ServletInvocableHandlerMethod#invokeAndHandle进行反射调用，其内部有#invokeForRequest以及HandlerMethodReturnValueHandlerComposite#handleReturnValue两个方法比较重要。具体处理如下。
	（6）getModelAndView——返回ModelAndView

// TODO
HandlerMethodArgumentResolverComposite.resolveArgument(MethodParameter, ModelAndViewContainer, NativeWebRequest, WebDataBinderFactory)
HandlerMethodArgumentResolverComposite.getArgumentResolver(MethodParameter),以MethodParameter从缓存Map<MethodParameter, HandlerMethodArgumentResolver> argumentResolverCache中获取对应的HandlerMethodArgumentResolver（以上缓存获取的键是MethodParameter，该类中不仅封装了参数类型，还封装了参数的参数名、附带的的各种注解等等，所以即使是不同方法、不同注解，相同又类型的参数依然不用担心会缓存调用到错误的argumentResolver），若获取不到，则逐个调用HandlerMethodArgumentResolver.supportsParameter(MethodParameter)获取，获取到了就放入缓存map中。

// TODO
而后调用入参WebDataBinderFactory.createBinder(NativeWebRequest, Object, String)进行参数绑定，在RequestMappingHandlerAdapter中，固定会调用createDataBinderFactory创建ServletRequestDataBinderFactory作为WebDataBinderFactory，然后会调用WebBindingInitializer.initBinder(WebDataBinder, WebRequest)迭代InitBinderDataBinderFactory#binderMethods，逐个调用InvocableHandlerMethod.invokeForRequest(NativeWebRequest, ModelAndViewContainer, Object...)，反射调用带@InitBinder的方法。
HttpMessageConverter进行数据的输入以及输出。
以servletRequest为入参，以request.getParameterNames获取参数名并逐个以getParameterValues获取参数值，最后封装成map返回，在WebUtils.getParametersStartingWith(ServletRequest, String)可见，最后调用MutablePropertyValues(Map<?, ?> original)构造MutablePropertyValues，将map转化成MutablePropertyValues.propertyValueList。


内部关系为：
RequestMappingHandlerAdapter.invokeHandlerMethod(HttpServletRequest, HttpServletResponse, HandlerMethod)封装ModelAndViewContainer、ServletWebRequest以及带有argumentResolvers、returnValueHandlers、binderFactory等的ServletInvocableHandlerMethod
调用ModelFactory.initModel(NativeWebRequest, ModelAndViewContainer, HandlerMethod)，其内部还会继续调用ModelFactory.invokeModelAttributeMethods(NativeWebRequest, ModelAndViewContainer)对含@ModelAttribute的方法进行反射调用。// TODO
ServletInvocableHandlerMethod.invokeAndHandle(ServletWebRequest, ModelAndViewContainer, Object...)
InvocableHandlerMethod.invokeForRequest(NativeWebRequest, ModelAndViewContainer, Object...)
HandlerMethodArgumentResolverComposite			argumentResolver    											HttpInputMessage
										===>							===>	HttpMessageConverter	===>	
HandlerMethodReturnValueHandlerComposite		returnValueHandlers   											HttpOutputMessage

https://my.oschina.net/lichhao/blog/172562
ServletInvocableHandlerMethod#invokeAndHandle调用两个方法：
invokeForRequest先通过适配器获取处理的controller，然后反射调用controller的方法，获取返回值
	其中#getMethodArgumentValues获取参数列表并绑定到java对象，#doInvoke反射执行controller方法获取返回值
handleReturnValue调用HandlerMethodReturnValueHandlerComposite#handleReturnValue根据controller的返回值以及返回值类型决定具体处理的处理器，然后将返回值写入，若处理器为RequestResponseBodyMethodProcessor，则消息转换过程如下。（同时在RequestResponseBodyMethodProcessor#handleReturnValue，会调用ModelAndViewContainer.setRequestHandled(boolean)将标识符改为true，表示该请求后续不再需要渲染视图了，随后会在RequestMappingHandlerAdapter.getModelAndView(ModelAndViewContainer, ModelFactory, NativeWebRequest)中判断该标识符，为true则会返回一个空的ModelAndView，于是@RequestResponseBodyMethodProcessor类型的doDispatcher到这里就执行完毕了）

springmvc messageConverter——
所有消息转换器都必须实现AbstractHttpMessageConverter，并重写supports(Class<?>)方法，以完成对canWrite和canRead方法的补充。
以两个接口为入参HttpInputMessage、HttpOutputMessage
HttpInputMessage——消息输入处理接口，作为HttpMessageConverter#read入参传入
HttpOutputMessage——消息输出处理接口，作为HttpMessageConverter#write入参传入
AnnotationDrivenBeanDefinitionParser#parse调用#getMessageConverters，该方法根据你classpath中存在的jar决定最终需要加载哪些messageConverter，然后当请求过来时根据客户端的accept、服务端的produces（由已注册的消息转换器的canWrite决定）决定当前请求的mediaType，然后循环迭代所有消息转换器判断canWrite决定由哪个messageConverter进行消息转换，最后由该消息转换器调用write方法输出（其中每个消息转换器在初始化的时候都会调用构造方法将自身可以处理的mediaType存入了自身的supportedMediaTypes中，以便在之后的produces的判断中能直接从其自身中获取并添加到局部变量中）——http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html

而非简单类型，且又不带参数注解的参数最终会进入ModelAttributeMethodProcessor#resolveArgument，经由bindRequestParameters获取ServletRequestDataBinder进行参数绑定，其会解析request并获取MutablePropertyValues（内部封装了以List<PropertyValue>——key，value形式封装了所有参数），然后经过以下一系列检查：
org.springframework.web.bind.WebDataBinder.checkFieldDefaults(MutablePropertyValues)
org.springframework.web.bind.WebDataBinder.checkFieldMarkers(MutablePropertyValues)
org.springframework.validation.DataBinder.checkAllowedFields(MutablePropertyValues)
org.springframework.validation.DataBinder.checkRequiredFields(MutablePropertyValues)
最终调用org.springframework.validation.DataBinder.applyPropertyValues(MutablePropertyValues)，并调用org.springframework.beans.AbstractNestablePropertyAccessor.processLocalProperty(PropertyTokenHolder, PropertyValue)
org.springframework.beans.AbstractNestablePropertyAccessor.convertForProperty(String, Object, Object, TypeDescriptor)
org.springframework.beans.TypeConverterDelegate.convertIfNecessary(String, Object, Object, Class<T>, TypeDescriptor)
并以org.springframework.core.convert.ConversionService.canConvert(TypeDescriptor, TypeDescriptor)分别以源数据类型以及目标数据类型构造ConverterCacheKey(sourceType, targetType)，并以其为key从Map<ConverterCacheKey, GenericConverter> converterCache中获取converter，最终调用org.springframework.core.convert.support中的对应转换器类进行转换赋值。（即conversionService中的默认converter，也可自定义类型转换器）


processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
主要有两个核心：// TODO
1、DispatcherServlet#processHandlerException(HttpServletRequest, HttpServletResponse, Object, Exception)
springmvc通用的处理异常的方法，其内部最终会通过ServletInvocableHandlerMethod.invokeAndHandle(ServletWebRequest, ModelAndViewContainer, Object...)反射调用含@ExceptionHandler的方法，进行异常处理。
2、DispatcherServlet.render(ModelAndView, HttpServletRequest, HttpServletResponse)
springmvc渲染视图的入口


/*****************************************************************************************/




hibernate-validate注解原理
ServletInvocableHandlerMethod#invokeAndHandle——InvocableHandlerMethod#invokeForRequest #getMethodArgumentValues——HandlerMethodArgumentResolverComposite#resolveArgument——ModelAttributeMethodProcessor#validateIfApplicable
springMVC容器在启动时会根据mvc的validator配置决定是否加载自定义校验器，如果没有配置，则会进行通用校验，即加载OptionalValidatorFactoryBean负责校验，而如果项目中加载了hibernate的校验器，则OptionalValidatorFactoryBean会加载hibernate的校验器到类内部的target中，这样在校验的时候实际上是通过代理模式调用了hibernate的校验逻辑。其中OptionalValidatorFactoryBean本身继承自LocalValidatorFactoryBean，而LocalValidatorFactoryBean是实现了javax.validation.Validator接口，同时也实现了InitializingBean，因而在初始化时，会调用其afterPropertiesSet方法，将hibernate的实现通过set方法设置到成员变量targetValidator中。
每当请求发送过来时，ConfigurableWebBindingInitializer#initBinder会将支持该注解或类的校验器保存起来，以便在接下来的检验中使用。

LocalValidatorFactoryBean#afterPropertiesSet()初始化springmvc默认的验证类，若项目内有hibernate-validator.jar时，则会以configuration加载其配置，即hibernate的验证机制，并调用#setTargetValidator将其（实质为ValidatorImpl实例）设置给其父类SpringValidatorAdapter#targetValidator，在之后的验证机制中，都将调用该targetValidator#validate进行验证。

DisposableBean#destroy——接口为bean提供了销毁方法
InitializingBean#afterPropertiesSet——接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。

AbstractAutowireCapableBeanFactory#invokeInitMethods调用afterPropertiesSet

@EnableWebMvc——以注解形式启用mvc注解，等同于在配置中申明<mvc:annotation-driven/>

post——参数以键值对形式隐藏在requestbody中

springboot学习
http://springboot.fun/

spring快速构建项目
http://start.spring.io/


https://blog.csdn.net/huyangyamin/article/details/52037060
@Resource——javax的规范，用于按名称注入，由CommonAnnotationBeanPostProcessor注册（RequiredAnnotationBeanPostProcessor）
@PostConstruct——执行时机在BeanDefinition前置方法之前，见CommonAnnotationBeanPostProcessor
@PreDestroy——见CommonAnnotationBeanPostProcessor
@Valid——参照JSR-303、JSR-349规范，使用默认校验规则

@Validated——springmvc的校验规范，可定义添加验证规则

@Autowired、@Value初始化，以及javax的@Inject的注入——AutowiredAnnotationBeanPostProcessor

CommonAnnotationBeanPostProcessor及其父类InitDestroyAnnotationBeanPostProcessor负责@PostConstruct、@PreDestroy初始化，还负责@Resource的注入
CommonAnnotationBeanPostProcessor、ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor等由<context:component-scan/>或<context:annotation-config/>的解析中通过AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object)统一注册

Ordered
@Order

@Param注解的解析见ParamNameResolver

SpringMvc注解
@GetMapping——spring4.3开始新增的注解，相当于@RequestMapping(method = RequestMethod.GET)
@RequestParam

Spring注解
@Cacheable，@CacheEvict——https://www.cnblogs.com/fashflying/p/6908028.html
@Async——异步方法注解
@DependsOn——告诉容器，本类需要依赖某个类，因而需要在该类初始化完成后再初始化本类
@Lazy
@Inject——AutowiredAnnotationBeanPostProcessor
@Autowired——AutowiredAnnotationBeanPostProcessor
@Value——AutowiredAnnotationBeanPostProcessor
@Required
@Qualified

Spring format注解
@DateTimeFormat
@NumberFormat

@Profile（其内部也是被@Conditional注解修饰）
@Condition——https://blog.csdn.net/qq_26525215/article/details/53510156
@Import——可引入——统一在ConfigurationClassPostProcessor（BeanDefinitionRegistryPostProcessor）.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)即AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)中被反射调用
可导入普通的类（即没有在xml中配置，且也不带@Component注解的类），该类中可以在不添加@Component的情况下使用@Bean注册bean
1、被Configuration注解修饰的类 {@link Configuration}
最常用的，通过cglib将@Configuration的类生成代理bean，可以将该类的方法参数中自动注入被@Import修饰的类中的注册bean
2、实现ImportSelector的类 {@link ImportSelector}
通过实现ImportSelector类完成的，原理为通过selectImports方法，返回想要导入的beanClassName，被返回的beanClassName可以被@Configuration修饰，在该类内部的@Bean的bean即可被导入到目标类中，到这里就等同于（1）中的@Configuration了，如：
spring-tx的@EnableTransactionManagement——TransactionManagementConfigurationSelector
spring-context的@EnableAsync——AsyncConfigurationSelector
3、实现ImportBeanDefinitionRegistrar的类 {@link ImportBeanDefinitionRegistrar}
通过实现registerBeanDefinitions方法批量注册beanDefinition，如mybatis的AutoConfiguredMapperScannerRegistrar就是通过实现该类进行扫描mapper注解注册为bean的。而扫描的basePackages可通过AutoConfigurationPackages.get(BeanFactory)获得。
/*********************************************/
（error）4、其他特殊的component组件类
/*********************************************/

Spring Config注解
@Configuration——org.springframework.context.annotation.ConfigurationClassPostProcessor（内部操作多借助于ConfigurationClassUtils）
在该注解修饰的类的方法上添加@Bean注解可以通过cglib生成代理对象
（1）ConfigurationClassUtils#isFullConfigurationCandidate(AnnotationMetadata)判断是否含有@Configuration
（2）ConfigurationClassUtils.isLiteConfigurationCandidate(AnnotationMetadata)判断是否含有@Component、@ComponentScan、@Import、@ImportResource注解
（3）ConfigurationClassUtils.isFullConfigurationClass(BeanDefinition)判断bd中的org.springframework.context.annotation.ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE是否为full，表示已被处理过
（4）ConfigurationClassUtils.isLiteConfigurationClass(BeanDefinition)判断bd中的org.springframework.context.annotation.ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE是否为lite，表示已被处理过
（5）ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory)会将未处理过的bean进行处理，并根据所含有的注解类型添加不同的org.springframework.context.annotation.ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE及org.springframework.context.annotation.ConfigurationClassUtils.ORDER_ATTRIBUTE

@Bean

加载规则注解
@ConditionalOnProperty（OnPropertyCondition——Ordered.HIGHEST_PRECEDENCE + 40）——havingValue与配置中一致时才实例化
@ConditionalOnBean（OnBeanCondition——Ordered.LOWEST_PRECEDENCE）——仅仅在当前上下文中存在某个对象时，才会实例化一个Bean
@ConditionalOnMissingBean（OnBeanCondition——Ordered.LOWEST_PRECEDENCE）——仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean
@ConditionalOnClass（OnClassCondition——Ordered.HIGHEST_PRECEDENCE）——某个class位于类路径上，才会实例化一个Bean
@ConditionalOnMissingClass（OnClassCondition——Ordered.HIGHEST_PRECEDENCE）——某个class类路径上不存在的时候，才会实例化一个Bean
@ConditionalOnResource（OnResourceCondition——Ordered.HIGHEST_PRECEDENCE + 20）——某个资源存在时，才会实例化一个Bean
@ConditionalOnExpression（OnExpressionCondition——Ordered.LOWEST_PRECEDENCE - 20）——当表达式为true的时候，才会实例化一个Bean
@ConditionalOnNotWebApplication——不是web应用


aspectj注解及表达式
https://www.cnblogs.com/caoyc/p/5629507.html

AOP注解
@Around，@Pointcut，@Before，@After，@Within
@Pointcut(value = "@annotation(com.stylefeng.guns.common.annotion.DataSource)")
@Around("cutService()")

JDK注解
@Inherited——被该注解修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类
@Retention——该注解被保留到何时期（内部使用RetentionPolicy枚举）
@Documented——被该注解修饰的类的注释会被javadoc记录
@Target——该注解可以修饰什么类型的对象（内部使用ElementType枚举）

JAVAX注解

Spring的Ordered顺序

分布式与集群
集群：多个相同的应用部署在多个机器上
分布式：一个应用拆分成多个模块部署在多个机器上

springboot的启动原理

logback的配置详解——http://tengj.top/2017/04/05/springboot7/



spring多数据源（AbstractRoutingDataSource）——https://blog.csdn.net/u012881904/article/details/77449710

DataSourceAutoConfiguration
DataSourceInitializer——初始化数据源，执行sql脚本

springboot自动加载bean原理：
自Condition接口开始，由抽象类SpringBootCondition实现，所有condition都继承自这个抽象类，每个condition都有自己的order，用于在容器初始化过程中，按次序加载各个被注解修饰的bean（存在于spring-boot-autoconfigure-x.x.x.jar中）

分布式事务——https://blog.csdn.net/bjweimengshu/article/details/79607522

SpringBoot内嵌tomcat源码context——EmbeddedWebApplicationContext——https://blog.csdn.net/liaokailin/article/details/52269786
ServerProperties#customize-负责加载tomcat配置的类



BeanDefinitionBuilder读取配置文件，通过#addPropertyValue，将配置以键值对的形式添加到其内部的beanDefinition中


Spring生命周期组件
通过实现java.io.Closeable接口，完成了统一的close销毁bean、beanFactory，并通过AbstractApplicationContext.getLifecycleProcessor()获取自身所有注册的生命周期组件，
spring自身的Lifecycle

/***********************************************************************************************************/

SpringAop源码部分

注解配置部分
org.springframework.transaction.config.AnnotationDrivenBeanDefinitionParser#parse
有两种mode
不论哪种模式，最后都会以AnnotationDrivenBeanDefinitionParser.registerTransactionManager(Element, BeanDefinition)将配置的transactionManager（默认为transactionManager，可不配置）以name=transactionManagerBeanName注入
1、aspectj——AnnotationDrivenBeanDefinitionParser.registerTransactionAspect(Element, ParserContext)
2、proxy——AnnotationDrivenBeanDefinitionParser.AopAutoProxyConfigurer.configureAutoProxyCreator(Element, ParserContext)
将transactionManager以name=transactionManagerBeanName注入TransactionInterceptor中，这个interceptor也是proxy模式的事务拦截器，最后再将其注入BeanFactoryTransactionAttributeSourceAdvisor#adviceBeanName（该bean实现了Advisor）中


SpringAop事务
TransactionAspectSupport#invokeWithinTransaction可通过代理method以及targetClass获取TransactionAttribute（内部存储了该方法的事务隔离、传播性、以及rollback-for），
然后调用InvocationCallback#proceedWithInvocation（实际类型为ReflectiveMethodInvocation），继而调用#invokeJoinpoint后由AopUtils#invokeJoinpointUsingReflection完成对目标service的反射调用。
spring对每个被代理的对象方法在被实际调用前都会先调用org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()，判断是否有拦截链，然后按次序执行拦截链上的方法，都执行完毕后，再反射调用本方法。
（需要注意的是所有以this或省略this调用的方法（包括private方法）均不会被spring代理，在此类方法中若抛出异常，且外部捕获后不处理时，事务将失效）
只有代理对象的方法才会被事务监控，而this是普通对象，不会被spring代理，因而事务也就不会生效了
http://jinnianshilongnian.iteye.com/blog/1487235
关于TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
spring在每次提交事务时，会检查其线程变量的rollback状态，若为true，则不会进行commit，而会选择rollback，而正常情况是遇到异常时，spring会自动调用这个方法设值，也可以用上述语句在遇到异常时手动设置回滚需求，效果等同。

https://blog.csdn.net/chjttony/article/details/6321440
org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()
首先会检查当前的index是否已等于当前方法所被包含的拦截链总数，即是否已执行完所有拦截方法，若已执行完，则反射执行本方法；否则依次从interceptorsAndDynamicMethodMatchers（List）中有序的从拦截链一个一个取出拦截器，依次执行，并将currentInterceptorIndex自增，直到其等于拦截链总数本身后，开始反射执行本方法。
根据每个被代理的方法的拦截链决定执行顺序，当拦截链上的每个切面方法都执行完毕时，开始反射执行本方法。
org.springframework.transaction.interceptor.TransactionInterceptor.invoke(MethodInvocation)
org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(Method, Class<?>, InvocationCallback)
org.springframework.transaction.interceptor.new InvocationCallback() {...}.proceedWithInvocation()
org.aopalliance.intercept.Joinpoint.proceed()
org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint()
org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(Object, Method, Object[])
java.lang.reflect.Method.invoke(Object, Object...)执行反射

TransactionAspectSupport#invokeWithinTransaction——invocation.proceedWithInvocation()
（出现异常catch）#completeTransactionAfterThrowing
txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus())
org.springframework.transaction.support.AbstractPlatformTransactionManager.rollback(TransactionStatus)
org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(DefaultTransactionStatus)
org.springframework.jdbc.datasource.DataSourceTransactionManager.doSetRollbackOnly(DefaultTransactionStatus)设置回滚标志，之后在事务commit时会检查该标志，即使异常被捕获，只要发现该标志被修改，事务依然会回滚，具体见：
org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(TransactionStatus)

SpringAop Bean的代理对象AopProxy创建过程
实现AopProxy接口的有JdkDynamicAopProxy和CglibAopProxy，这是SpringAop主要的两种aop代理对象的类型
1、AnnotationAwareAspectJAutoProxyCreator，负责一般的aop对象的生成，在org.springframework.aop.config.AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry, Object)中完成注册，成为BeanDefinition。
而AnnotationAwareAspectJAutoProxyCreator继承了AbstractAutoProxyCreator，其实现了BeanPostProcessor接口，在AbstractApplicationContext#registerBeanPostProcessors中注册成为BeanPostProcessor，以其作为切入点生成代理对象，其由普通bean转变为代理对象的过程借由实现了BeanPostProcessor的AbstractAutoProxyCreator#postProcessAfterInitialization后置方法完成。
// TODO DefaultBeanFactoryPointcutAdvisor、ExposeInvocationInterceptor
在AbstractAutoProxyCreator.createProxy(Class<?>, String, Object[], TargetSource)中会通过proxyFactory创建该bean所需的Advisor并逐个添加到proxyFactory中实现代理的增强逻辑。
AbstractAutoProxyCreator
ConcurrentHashMap<Object, Boolean> AbstractAutoProxyCreator.advisedBeans——key为beanName，value为是否需要增强逻辑的boolean的flag
ConcurrentHashMap<Object, Class<?>> AbstractAutoProxyCreator.proxyTypes——key为beanName，value为生成的代理class
// TODO
org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findCandidateAdvisors()

BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans()从beanFactory中获取Advisor，获取不到，表示不必代理，即返回AbstractAutoProxyCreator.DO_NOT_PROXY
获取到了，AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(List<Advisor>, Class<?>, String)调用AopUtils.canApply(Advisor, Class<?>)传入增强器和需要代理的class，由其判断是否需要代理。

org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(Object, String)

org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(Object, String)

org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(Object, String, Object)
其中，AbstractAutoProxyCreator.proxyTypes以key=aop目标对象名，value=代理类名存储所有需要被代理的实例
AbstractAutoProxyCreator.advisedBeans以key=aop目标对象cache名，value=是否需要被增强，即是否需要被代理，之后便根据此值决定是否需要代理。
若不需要被代理则直接返回实例bean，若需要代理，则开始生成代理对象

org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(Class<?>, String, Object[], TargetSource)
该方法中会判断配置的proxyTargetClass是否为false，若为false，则会调用AbstractAutoProxyCreator.shouldProxyTargetClass(Class<?>, String)，若为true，则设置proxyTargetClass为true，否则执行ProxyProcessorSupport.evaluateProxyInterfaces(Class<?>, ProxyFactory)判断targetClass是否有实现的接口，如果有则逐个加入proxyFactory#interfaces，否则说明无实现接口，则说明不能使用jdk代理，设置proxyTargetClass为true，之后会使用cglib进行代理

org.springframework.aop.framework.ProxyFactory.getProxy(ClassLoader)

org.springframework.aop.framework.ProxyCreatorSupport.createAopProxy()

org.springframework.aop.framework.DefaultAopProxyFactory.createAopProxy(AdvisedSupport)

2、AsyncAnnotationBeanPostProcessor（AbstractBeanFactoryAwareAdvisingPostProcessor->AbstractAdvisingBeanPostProcessor），同样继承自ProxyConfig，负责@Async注解的异步方法的代理对象的生成。
生成时机在AbstractAdvisingBeanPostProcessor.postProcessAfterInitialization(Object, String)中，由AbstractAdvisingBeanPostProcessor.isEligible(Class<?>)负责过滤其他无需代理对象，该方法内部同样会调用AopUtils.canApply(Advisor, Class<?>)决定当前advisor是否具有代理target的必要。
其拦截器为AnnotationAsyncExecutionInterceptor（AsyncExecutionInterceptor->AsyncExecutionAspectSupport，实现MethodInterceptor），由proxy对象调用AsyncExecutionInterceptor.invoke(MethodInvocation)反射执行


代理对象的反射调用——https://blog.csdn.net/zknxx/article/details/80087623
spring代理对象——AopProxy
mybatis代理对象——MapperProxy
org.springframework.aop.framework.JdkDynamicAopProxy.invoke(Object, Method, Object[])
？
根据chain是否为空，为空直接调用org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(Object, Method, Object[])，否则创建ReflectiveMethodInvocation(Object, Object, Method, Object[], Class<?>, List<Object>)，由其继续根据内部的拦截器链逐个执行，不论如何执行，最后都会递归调用自己proceed，当所有拦截器都执行完毕时，即this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1时，执行ReflectiveMethodInvocation.invokeJoinpoint()，其内部依然是调用AopUtils.invokeJoinpointUsingReflection执行真正的反射调用target的方法。




关于bean的id、name、alias——https://blog.csdn.net/aitangyong/article/details/50629525

/***********************************************************************************************************/

spring
http://jinnianshilongnian.iteye.com/blog/1482071

spring循环依赖
https://blog.csdn.net/u010853261/article/details/77940767
https://blog.csdn.net/u010644448/article/details/59108799

ApplicationContext也是BeanFactory的子接口，只不过多了一些自定义的方法


BeanDefinition简介
BeanDefinition继承自AttributeAccessor, BeanMetadataElement
而AbstractBeanDefinition继承自BeanMetadataAttributeAccessor（同时实现了AttributeAccessor、BeanMetadataElement），可从bd中调用getAttribute、setAttribute获取或设置需要设置的值。
其中，AttributeAccessor接口定义了最基本的对任意对象的元数据的修改或者获取
BeanMetadataElement接口提供了一个getResource()方法,用来传输一个可配置的源对象。
AbstractBeanDefinition——BeanDefinition的抽象实现类，但是提供了BeanDefinition接口的全部实现。是一个基本的框架。其子类有RootBeanDefinition（表示父级），ChildBeanDefinition（表示子级）和GenericBeanDefinition（一般的BeanDefinition实现）。
AnnotatedBeanDefinition——BeanDefinition的子接口，基于注解方式实现的BeanDefinition，其实现类有AnnotatedGenericBeanDefinition、ConfigurationClassBeanDefinition、ScannedGenericBeanDefinition
这三个实现类中，AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition既继承自GenericBeanDefinition，又实现了AnnotatedBeanDefinition
而ConfigurationClassBeanDefinition既继承自RootBeanDefinition，又实现了AnnotatedBeanDefinition
由此可见，所有的BeanDefinition的实现类皆是继承自AbstractBeanDefinition，由其提供统一的公用实现

内部
AbstractBeanDefinition
MutablePropertyValues-propertyValues——bean的配置参数列表，内部有一个PropertyValue集合，以key-bean的参数字段名，value-bean的对应参数字段值对应
ConstructorArgumentValues-constructorArgumentValues——bean的构造器参数管理器，可以以argumentName以及argumentIndex两种方式给构造函数带参
String[]-dependsOn-当前bean依赖的beanName列表


BeanDefinitionHolder
private final BeanDefinition beanDefinition;——当前holder持有的beanDefinition
private final String beanName;——当前holder持有的beanDefinition的名称
private final String[] aliases;——当前holder持有的beanDefinition的别名


BeanComponentDefinition(继承自BeanDefinitionHolder，实现ComponentDefinition)
BeanDefinition[] innerBeanDefinitions——封装的内部bean集合
BeanReference[] beanReferences——封装的bean引用集合

Xml Bean解析

Spring xml默认的四种标签import、alias、bean、beans由DefaultBeanDefinitionDocumentReader#parseDefaultElement统一解析
其中每个<bean>最后都将由BeanDefinitionParserDelegate完成统一的解析，并转化为BeanDefinition，最后再包装成BeanDefinitionHolder，由BeanDefinitionReaderUtils#registerBeanDefinition调用入参registry即DefaultListableBeanFactory（实为SimpleBeanDefinitionRegistry）完成注册，保存到SimpleBeanDefinitionRegistry#beanDefinitionMap中。

而其他节点由BeanDefinitionParserDelegate#parseCustomElement处理，首先会根据Element获取处理的uri，之后由uri获取绑定的NamespaceHandler，最后再由Element获取对应的BeanDefinitionParser，最后调用自定义后的BeanDefinitionParser的实现类的#parse进行自定义的解析，最后封装成BeanDefinition。

BeanDefinition与Bean——https://blog.csdn.net/lh513828570/article/details/74078804
每个Bean对应的spring内部结构，包含该bean的所有配置属性，其中AbstractBeanDefinition.propertyValues存储了该bean的一些自定义的property属性，以key：value形式保存。
经由AbstractAutowireCapableBeanFactory#populateBean判断注入策略（名称RootBeanDefinition#AUTOWIRE_BY_NAME或类型RootBeanDefinition#AUTOWIRE_BY_TYPE）并调用AbstractAutowireCapableBeanFactory#applyPropertyValues(String, BeanDefinition, BeanWrapper, PropertyValues)注入bean
/*********************error************************/
（#getPropertyValues包括通用的lazyInit以及自定义的transactionManager等）
/*********************error************************/

基于注解的Bean
基于@Component实现，由<context:component-scan/>即ComponentScanBeanDefinitionParser完成统一的解析，若不将use-default-filters设置为false时，将对所有包含@Component的bean生效，见#configureScanner和#createScanner。最后经由ClassPathBeanDefinitionScanner#doScan(String basePackages)，调用ClassPathMapperScanner#doScan将已生成的BeanDefinition转化为BeanDefinitionHolder。
需要提醒的是
1、ComponentScanBeanDefinitionParser#parse中，会调用ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS，和xml中的contextConfigLocation一样将basePackages以spring式的拆分，即以",; \t\n"拆分每一个配置文件
2、ClassPathScanningCandidateComponentProvider#findCandidateComponents中，我们看到basePackages以spring式的拆分，会以"classpath*:"+basePackage+"/"+"**/*.class"方式拼接，即默认在只写包名的情况下，也会对该包下的子包以及所有类都解析成BeanDefinitionHolder并注册到容器中。
继承关系为：
ClassPathScanningCandidateComponentProvider
ClassPathBeanDefinitionScanner
ClassPathMapperScanner

Bean装配（AbstractAutowireCapableBeanFactory）——https://blog.csdn.net/taotao4/article/details/43852461
首先明确继承关系：
BeanFactory——只封装了一些基础bean方法
1、getBean——根据beanName、beanClass等参数获取bean
2、containsBean——是否包含bean
3、isSingleton——是否单例bean
4、isPrototype——是否多例bean
5、isTypeMatch——根据beanName与typeClass是否匹配
6、getType——根据beanType获取beanClass
7、getAliases——根据别名获取beanName

HierarchicalBeanFactory分层beanFactory（getParentBeanFactory、containsLocalBean）
ListableBeanFactory——getBeanNamesForType、getBeansOfType、getBeanDefinitionNames、getBeanDefinitionCount
ConfigurableListableBeanFactory——getBeanDefinition、registerResolvableDependency、isAutowireCandidate

AbstractBeanFactory——实现ConfigurableBeanFactory（setParentBeanFactory、setConversionService、addEmbeddedValueResolver、addBeanPostProcessor等bean配置的方法）——继承自HierarchicalBeanFactory分层beanFactory（getParentBeanFactory、containsLocalBean）
AbstractAutowireCapableBeanFactory——实现AutowireCapableBeanFactory（提供createBean、autowireBean、initializeBean、destroyBean等bean创建、操作、初始化等操作方法）
DefaultListableBeanFactory——实现ConfigurableListableBeanFactory——实现ListableBeanFactory

DefaultListableBeanFactory——spring核心bean工厂，职责非常多：
1、作为AliasRegistry，继承自SimpleAliasRegistry——别名注册器，可进行bean的name与alias的绑定以及通过别名获取beanName
2、作为SingletonBeanRegistry，由DefaultSingletonBeanRegistry实现，维护了一些缓存map，如singletonObjects、singletonFactories，前者负责baneName与实际单例bean实例的映射，而后者负责beanName与ObjectFactory的映射。可直接将单例bean实例放入缓存中，以便下次直接获取。
3、作为BeanDefinitionRegistry（继承自AliasRegistry，由DefaultListableBeanFactory自身实现），bean注册器，内部维护了beanDefinitionMap，完成了beanName与beanDefinition的绑定关系，beanDefinition的注册器。
4、作为FactoryBeanRegistrySupport，内部有缓存的factoryBean，可获取特殊的factoryBean，同时对factoryBean封装了一些特殊的方法
5、作为BeanFactory，可通过name，class获取、创建各种bean
这里主要容易搞混的是SingletonBeanRegistry与BeanDefinitionRegistry：
SingletonBeanRegistry——注册的是单例bean实例，可在不注册beanDefinition的情况下直接注册到SingletonBeanRegistry#singletonObjects，获取时直接以beanName即可获取，无需创建。
BeanDefinitionRegistry——注册的是beanDefinition，获取的时候也需要beanName或class，如果单例则可直接从SingletonBeanRegistry#singletonObjects中获取，获取不到时，以及多例模式下，都是创建实例，然后注册到SingletonBeanRegistry#singletonObjects中，下次就无需再创建，直接获取即可。

ApplicationContext
继承自：
1、EnvironmentCapable
2、ListableBeanFactory
3、HierarchicalBeanFactory
4、MessageSource——getMessage
5、ApplicationEventPublisher
6、ResourcePatternResolver


// TODO
几个容易搞混的类：
1、BeanPostProcessor——在每个bean实例化的前后被调用，AbstractAutowireCapableBeanFactory.initializeBean(String, Object, RootBeanDefinition)
2、BeanDefinitionRegistry——bean注册器，每个bean通过beanDefinition注册时都需要调用此接口
3、BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，——AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)调用执行，mybatis的扫描器MapperScannerConfigurer就是以实现此接口的形式加载的。
4、BeanFactoryPostProcessor——AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)调用执行，spring加载配置的PropertyPlaceholderConfigurer就是以实现此接口的形式加载的。


BeanFactoryPostProcessor——允许使用者修改容器中的BeanDefinition，但是不能进行bean实例化，会引起不可预估的错误，其执行时机在AbstractApplicationContext#refresh的invokeBeanFactoryPostProcessors中
BeanPostProcessor——bean后置处理器，允许使用者在bean实例化后、InitializingBean#afterPropertiesSet之前执行一些个性化操作，若该bean为懒加载模式，则方法不会执行
具体方法在AbstractAutowireCapableBeanFactory#initializeBean中
执行顺序为：（需要注意的是其其实是由其父类AbstractBeanFactory#getBean经过层层调用，发现该bean尚未初始化时才会执行）
AbstractAutowireCapableBeanFactory#invokeAwareMethods试图将bean转化为各种Aware，若转化成功，则调用对应的注入方法（主要包含BeanNameAware、BeanClassLoaderAware以及BeanFactoryAware）
（其余的Aware如ApplicationContextAware、MessageSourceAware等则通过ApplicationContextAwareProcessor，实质是实现BeanPostProcessor，在前置方法中注入）
BeanPostProcessor#postProcessBeforeInitialization前置方法
InitializingBean#afterPropertiesSet
init-method中配置的自定义初始化方法
BeanPostProcessor#postProcessAfterInitialization后置方法

BeanPostProcessor分类：
（1）BeanPostProcessor：负责bean初始化前的操作，postProcessBeforeInitialization、postProcessAfterInitialization，若不操作直接返回bean即可
（2）InstantiationAwareBeanPostProcessor（继承自BeanPostProcessor）：负责bean实例化的各种操作，postProcessBeforeInstantiation（不操作返回null）负责实例化前的操作、postProcessAfterInstantiation（不操作返回true）负责实例化后的操作、postProcessPropertyValues（不操作返回pvs）负责填充bean
（3）SmartInstantiationAwareBeanPostProcessor（继承自InstantiationAwareBeanPostProcessor）：predictBeanType、determineCandidateConstructors、getEarlyBeanReference负责解决代理对象循环依赖的提前暴露问题
（4）MergedBeanDefinitionPostProcessor（继承自BeanPostProcessor）：postProcessMergedBeanDefinition

处理类：
InitDestroyAnnotationBeanPostProcessor（MergedBeanDefinitionPostProcessor）：
CommonAnnotationBeanPostProcessor（InitDestroyAnnotationBeanPostProcessor）：@PostConstruct、@PreDestroy（基于InitDestroyAnnotationBeanPostProcessor）;@Resource
AutowiredAnnotationBeanPostProcessor（SmartInstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor）：@Autowired、@Injected
RequiredAnnotationBeanPostProcessor（SmartInstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor）：@Required

ApplicationContextAwareProcessor（继承自BeanPostProcessor）：前置方法postProcessBeforeInitialization对ApplicationContextAware、MessageSourceAware等Aware的注入。

ScheduledAnnotationBeanPostProcessor：// TODO

Aop相关：可详见"AOP配置beanPostProcessor"
InfrastructureAdvisorAutoProxyCreator（AbstractAutoProxyCreator->SmartInstantiationAwareBeanPostProcessor）事务注解的aop对象的生成
AspectJAwareAdvisorAutoProxyCreator（AbstractAutoProxyCreator->SmartInstantiationAwareBeanPostProcessor）基于配置的aop代理对象的生成
AnnotationAwareAspectJAutoProxyCreator（AspectJAwareAdvisorAutoProxyCreator->AbstractAutoProxyCreator->SmartInstantiationAwareBeanPostProcessor）扩展对@Aspect注解的支持，基于@Aspect注解的aop代理对象的生成

AsyncAnnotationBeanPostProcessor负责@Async的bean代理的生成

@Configuration与@Bean的处理类ConfigurationClassPostProcessor与上述的略有不同，实现的是BeanDefinitionRegistryPostProcessor

AnnotationUtils封装了spring对注解的处理，并在4.2后引入了@AliasFor的别名注解方式，由于spring基于注解的操作都基于此类，所以只需修改这一个类即可在注解工具类内统一进行@AliasFor的处理，以达到公用性。


/******************************************************************/

// TODO AbstractEnvironment——spring一些通用的环境变量

// TODO
Spring容器初始化核心方法——AbstractApplicationContext#refresh解析——https://blog.csdn.net/bubaxiu/article/details/41380683

prepareRefresh();

ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
构建beanFactory，其实是构建DefaultListableBeanFactory，这是一个非常重要的方法，spring对xml的解析就在这里进行，并将xml中的各种tag解析成具体的BeanDefinition，并注册到beanFactory。

prepareBeanFactory(beanFactory);
初始化容器的一些准备工作，期间会调用一些配置beanFactory的方法：
ConfigurableListableBeanFactory.ignoreDependencyInterface(Class<?>)
由AbstractAutowireCapableBeanFactory.ignoreDependencyInterface(Class<?>)实现，其会将入参class保存到内部的Set<Class<?>>——ignoredDependencyInterfaces中，用于在AbstractAutowireCapableBeanFactory.isExcludedFromDependencyCheck(PropertyDescriptor)中调用
ConfigurableListableBeanFactory.registerResolvableDependency(Class<?>, Object)
由DefaultListableBeanFactory.resolvableDependencies实现，将入参dependencyType和autowiredValue注册到resolvableDependencies中，用于在调用DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor)时完成注入。
其中dependencyType为依赖类型，autowiredValue为注入的值，也可能为ObjectFactory，那就需要再调用#getObject返回实例了。


postProcessBeanFactory(beanFactory);
该方法在子类AbstractRefreshableWebApplicationContext中被重写，调用WebApplicationContextUtils#registerWebApplicationScopes(ConfigurableListableBeanFactory, ServletContext)，用以注册ServletRequest、ServletResponse、HttpSession以及WebRequest到DefaultListableBeanFactory#resolvableDependencies，以给之后需要调用的request、response、session等绑定对应的对象工厂，见ConfigurableListableBeanFactory#registerResolvableDependency。
一般的bean都不会存入该resolvableDependencies，只有一些特殊的内置的bean才会被存进去。

invokeBeanFactoryPostProcessors(beanFactory);
// 调用所有BeanFactoryProcessor的postProcessBeanFactory()方法
装载并执行BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor的入口，通过beanFactory获取所有实现了BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor的bean，并逐个加载
首先调用PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
对传入的List<BeanFactoryPostProcessor>逐个进行判断，若能转换为BeanDefinitionRegistryPostProcessor则加入registryPostProcessors，否则加入regularPostProcessors。
（Mybatis的mapper scan就是通过实现BeanDefinitionRegistryPostProcessor并重写postProcessBeanDefinitionRegistry实现的，见MapperScannerConfigurer）而后分别调用
#invokeBeanFactoryPostProcessors执行BeanFactoryPostProcessor#postProcessBeanFactory和#invokeBeanDefinitionRegistryPostProcessors执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry完成初始化。

registerBeanPostProcessors(beanFactory);
// 注册BeanPostProcessor，BeanPostProcessor作用是用于拦截Bean的创建
1、该方法首先调用DefaultListableBeanFactory.getBeanNamesForType(Class<?>, boolean, boolean)从beanFactory中获取实现BeanPostProcessor的bean，此方法内部根据includeNonSingletons即是否包含非单例bean是否为true，若包含，则从allBeanNamesByType中获取beanNames，否则从singletonBeanNamesByType中获取，这两个map的key均为class，value为String[]类型的beanNames，这里先根据type从其中一个map中获取，若获取不到，则调用DefaultListableBeanFactory.doGetBeanNamesForType(ResolvableType, boolean, boolean)获取，获取到了就添加到对应的allBeanNamesByType或singletonBeanNamesByType中。
2、通过BeanFactory.isTypeMatch(String, Class<?>)等方式，将这些beanNames的bean进行分类，分类规则为：
	（1）实现了PriorityOrdered——添加到priorityOrderedPostProcessors
	（2）实现了Ordered——添加到orderedPostProcessorNames
	（3）都没实现的——添加到nonOrderedPostProcessors
	除此之外，上述三种beanNames还会根据是否实现了MergedBeanDefinitionPostProcessor进行分类
	（4）实现了MergedBeanDefinitionPostProcessor——添加到internalPostProcessors
3、调用PostProcessorRegistrationDelegate.sortPostProcessors(ConfigurableListableBeanFactory, List<?>)
将priorityOrderedPostProcessors、orderedPostProcessorNames、internalPostProcessors进行排序
4、PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, List<BeanPostProcessor>)
调用AbstractBeanFactory.addBeanPostProcessor(BeanPostProcessor)将上述四种beanPostProcessor逐个添加到AbstractBeanFactory.beanPostProcessors中，在添加前，其会先将beanPostProcessor做移除操作，然后再添加，以防出现重复的beanPostProcessor，同时若beans中包含InstantiationAwareBeanPostProcessor，则设置AbstractBeanFactory.hasInstantiationAwareBeanPostProcessors为true，若包含DestructionAwareBeanPostProcessor，则设置hasDestructionAwareBeanPostProcessors为true

注册BeanPostProcessor的入口，在这里注册该实例用以支持bean初始化的#postProcessBeforeInitialization和#postProcessAfterInitialization，其具体的执行时机在bean的实例化时，即AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[])时。

initMessageSource();
// 初始化MessageSource

initApplicationEventMulticaster();
// 从beanFactory中查找applicationEventMulticaster，若没有则会初始化一个SimpleApplicationEventMulticaster并注册到beanFactory

onRefresh();
// 初始化其他的特殊bean

registerListeners();
// 注册监听器

finishBeanFactoryInitialization(beanFactory);
// 非延迟加载的单例Bean实例化
1、从beanFactory判断是否含有ConfigurableApplicationContext.CONVERSION_SERVICE_BEAN_NAME即conversionService的bean，所有则添加到容器
2、调用ConfigurableBeanFactory.hasEmbeddedValueResolver()判断embeddedValueResolvers即StringValueResolver集合是否为空，一般spring父容器不会为空，而mvc容器为空，为空则会加载一个内部类，这也是为什么子容器无法获取到被@Value注解注入的值的原因了。
初始实例化所有bean的地方，见DefaultListableBeanFactory#preInstantiateSingletons，获取所有beanNames即DefaultListableBeanFactory#beanDefinitionNames，然后根据beanName从AbstractBeanFactory#mergedBeanDefinitions这个map中获取对应的BeanDefinition，若其AbstractBeanDefinition#lazyInit为true则会延迟加载，否则最终会调用AbstractBeanFactory#getBean实例化该bean。

finishRefresh();

/******************************************************************/

// TODO http://www.cnblogs.com/digdeep/p/4518571.html
org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(Class<T>, Object...)待完善


bean调用过程
AbstractApplicationContext#getBean(String)——getBeanFactory().getBean(),故实质是调用内部的DefaultListableBeanFactory实现的。
而DefaultListableBeanFactory#getBean，实质上是对其父类AbstractBeanFactory的getBean重载的补充，多数的getBean方法都定义在AbstractBeanFactory中。
然而，不论以哪一种形式获取bean，最终都会调用AbstractBeanFactory#doGetBean根据BeanDefinition获取每个bean。如通过beanClass获取bean也会被转化为beanName，然后用beanName调用doGetBean获取bean实例（见DefaultListableBeanFactory.resolveNamedBean(Class<T>, Object...)）
AbstractBeanFactory#doGetBean(String, Class<T>, Object[], boolean)解析
1、AbstractBeanFactory#doGetBean，会调用org.springframework.beans.factory.support.AbstractBeanFactory.transformedBeanName(String)对name进行解析，主要做了两件事：
	（1）将name开头的所有"&"去除，并赋值给beanName，如此一来，name负责处理与factoryBean有关的bean获取，而beanName则用来获取所有其他bean。
	（2）以转换后的name调用SimpleAliasRegistry.canonicalName(String)，以alias别名换取id
2、尝试以singleton的方式调用DefaultSingletonBeanRegistry.getSingleton(String)获取bean，
这个方法还会以allowEarlyReference=true即允许早期引用的形式继续调用getSingleton(String beanName, boolean allowEarlyReference)。
该方法会先从一级缓存singletonObjects以及二级缓存earlySingletonObjects中获取，若依然获取不到，由于allowEarlyReference=true，则会继续从三级缓存singletonFactories中获取objectFactorys，若获取到了就以objectFactory#getObject的方式获取bean。
执行过程可能是以下的几种情况：
	（1）从一级缓存singletonObjects中获取bean，若获取到了说明获取的bean早就被创建好了，否则继续获取
	（2）一级缓存未获取到，继续从二级缓存earlySingletonObjects中获取，若获取到了，说明该beanName虽然已被创建完毕，但还非完全实例化完毕（singletonsCurrentlyInCreation中必然存在该beanName），只是提早暴露了出来而已。（而之所以会在二级缓存earlySingletonObjects中，请看（3））
	（3）一级、二级缓存中都未获取到，且allowEarlyReference=true的时候，从三级缓存singletonFactories中获取，获取到的是objectFactory，若获取到了，说明当前beanName正在创建中，尚未完全创建完毕，只是提前将自己的制造工厂——ObjectFactory暴露出来了而已，然后继续调用ObjectFactory#getObject获取bean，一般而言，这里的ObjectFactory#getObject都是在AbstractAutowireCapableBeanFactory.doCreateBean(String, RootBeanDefinition, Object[])中添加的，且getObject方法是调用AbstractAutowireCapableBeanFactory.getEarlyBeanReference(String, RootBeanDefinition, Object)获取早期引用的。
	（4）三级缓存中也没有获取到，说明当前bean尚未被加载过，方法执行完毕，doGetBean继续向下执行。
3、根据之前的getSingleton(String)是否从缓存中获取到了bean决定如何执行：
	（1）若获取到了，则继续调用AbstractBeanFactory.getObjectForBeanInstance(Object, String, String, RootBeanDefinition)判断该类是否实现了FactoryBean，若实现了则调用getObject获取bean，否则依然返回bean。
	（2）若未获取到则说明该bean尚未被初始化或者其根本就不是单例而是多例，继续执行下去
4、AbstractBeanFactory.getParentBeanFactory()尝试获取父bean工厂，
若是spring容器则获取为空，调用本容器获取bean，
若是springMvc则获取父容器，若父容器不为空，且子容器通过调用AbstractBeanFactory.containsBeanDefinition(String)又获取不到该BeanDefinition时，将以父容器继续调用BeanFactory.getBean(String, Object...)获取bean并返回。
5、org.springframework.beans.factory.support.AbstractBeanFactory.markBeanAsCreated(String)
用来标记当前bean是否已被创建完毕的方法，若当前bean尚未被创建，则执行完该方法，其就会被加入到AbstractBeanFactory.alreadyCreated中，表示该bean已被创建或即将被创建。
根据doGetBean的第三个参数markBeanAsCreated决定是否执行该方法，目前的所有getBean方法都默认会将typeCheckOnly设置为false，即都会执行该方法。
该方法以双重判断——（!this.alreadyCreated.contains(beanName)）的方式，先执行一次包含判断，若不包含，则锁定this.mergedBeanDefinitions，然后再执行一次包含判断，若依然不存在，则调用AbstractBeanFactory.clearMergedBeanDefinition(String)将当前beanName从mergedBeanDefinitions中移除，并将该beanName加入到AbstractBeanFactory#alreadyCreated中。
6、org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(String)，获取合并后的本地bd，根据beanName从Map<String, RootBeanDefinition>——AbstractBeanFactory#mergedBeanDefinitions中获取RootBeanDefinition，若获取不到，则调用DefaultListableBeanFactory.getBeanDefinition(String)从DefaultListableBeanFactory.beanDefinitionMap中获取BeanDefinition，获取不到就抛出NoSuchBeanDefinitionException，否则就继续调用AbstractBeanFactory.getMergedBeanDefinition(String, BeanDefinition)
7、根据RootBeanDefinition#getDependsOn()获取该bean的依赖，并获取到了则通过for循环，逐个以DefaultSingletonBeanRegistry.registerDependentBean(String, String)并通过AbstractBeanFactory.getBean(String)保证当前Bean依赖的Bean全部被初始化，所以递归getBean。
8、根据RootBeanDefinition#isSingleton()或isPrototype()决定
若是单例，则调用DefaultSingletonBeanRegistry.getSingleton(String, ObjectFactory<?>)，同时通过内部类的方式重写了ObjectFactory#getObject，其会先从缓存DefaultSingletonBeanRegistry#singletonObjects中获取，获取不到则获取父类factoryBean继续获取该bean，若还无法获取，说明该bean还未被实例化，这样该方法最后会调用这个被重写的方法即执行AbstractBeanFactory#createBean进行创建bean的操作，实例化完成后，调用DefaultSingletonBeanRegistry.addSingleton(String, Object)将其放入缓存map-singletonObjects中，这样之后调用就不会再创建了；
若是多例，则会直接调用上述AbstractBeanFactory#createBean直接创建bean。
若均不是，则调用AbstractBeanDefinition.getScope()获取该bean的Scope，而后重写Scope#getObject并调用Scope.get(String, ObjectFactory<?>)获取bean实例，最终依然会调用刚才重写的getObject并调用createBean创建bean。

AbstractBeanDefinition.resolveBeanClass：在每次在调用AbstractAutowireCapableBeanFactory.createBean(String, RootBeanDefinition, Object[])时，由于AbstractBeanDefinition.beanClass是Object类型，但是每次注入的未必都是class类型，还可能是string的类全限定名。
	1、所以必须先调用AbstractBeanDefinition.resolveBeanClass(ClassLoader)，利用ClassUtils#forName将className由string加载为class，返回为resolvedClass
	2、然后调用入参mbd#hasBeanClass（内部以this.beanClass instanceof Class）确定原bd是否有beanClass，若没有，则调用RootBeanDefinition.RootBeanDefinition(RootBeanDefinition)的同bd构造，将入参bd构造成新的bd，并将刚才返回的resolvedClass作为新的beanClass以mbdToUse.setBeanClass(resolvedClass)赋值

AbstractBeanDefinition.prepareMethodOverrides()

AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(String, RootBeanDefinition)该方法会根据beanDefinition#beforeInstantiationResolved（Boolean，初始为null）的配置决定是否在初始化之前先调用BeanPostProcessors
	（1）若beanDefinition#beforeInstantiationResolved为true，则会调用AbstractBeanFactory.hasInstantiationAwareBeanPostProcessors()判断当前beanFactory是否有InstantiationAwareBeanPostProcessors。
	（2）若有会先调用AbstractAutowireCapableBeanFactory.determineTargetType(String, RootBeanDefinition, Class<?>...)确定目标类的beanClass，若不存在
	（3）若targetType存在，则逐个调用applyBeanPostProcessorsBeforeInstantiation，加载bean（其内部是逐个判断InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation）
	（4）若返回的bean为空，则方法结束，若不为空，则继续调用applyBeanPostProcessorsAfterInitialization（其内部是逐个判断BeanPostProcessor#postProcessAfterInitialization）
	（5）只要初始化前该bean依然为空，则会将beforeInstantiationResolved赋值为false，表示初始化前未完成加载
	完成之后，若bean依然为空，则赋值beanDefinition#beforeInstantiationResolved（表示初始化前已完成加载）为false，否则beanDefinition#beforeInstantiationResolved为true
（InstantiationAwareBeanPostProcessor继承自BeanPostProcessor），并扩展了以下三个方法：
Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;——父类同名方法的扩展
boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;——父类同名方法的扩展
PropertyValues postProcessPropertyValues(
			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;——用以在AbstractAutowireCapableBeanFactory.populateBean(String, RootBeanDefinition, BeanWrapper)时填充bean的内部属性的方法

经过resolveBeforeInstantiation之后，若bean已有值，则将该bean返回，方法结束；否则继续。

AbstractAutowireCapableBeanFactory.doCreateBean
	1、调用子类的AbstractAutowireCapableBeanFactory.doCreateBean(String, RootBeanDefinition, Object[])继续创建bean
	（1）先从AbstractAutowireCapableBeanFactory.factoryBeanInstanceCache中获取BeanWrapper
	（2）若没获取到则通过AbstractAutowireCapableBeanFactory.createBeanInstance(String, RootBeanDefinition, Object[])创建BeanWrapper，内部会先获取bd#resolvedConstructorOrFactoryMethod，继而通过BeanUtils.instantiateClass(Constructor<T>)传入构造器实例化bean
	（3）BeanWrapper#getWrappedInstance构建bean实例
	（4）判断RootBeanDefinition.postProcessed即后置处理是否完成，未完成调用AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String)逐个调用MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String)，完成后标记RootBeanDefinition.postProcessed为true
	（5）由(mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName))
		（1）单例（2）AbstractAutowireCapableBeanFactory#allowCircularReferences为true即允许循环引用（3）DefaultSingletonBeanRegistry.singletonsCurrentlyInCreation中包含该beanName，即当前bean正在创建中
	判断earlySingletonExposure即是否允许提早暴露未完全初始化的bean
	（6）DefaultSingletonBeanRegistry.addSingletonFactory(String, ObjectFactory<?>)重写ObjectFactory#getObject为AbstractAutowireCapableBeanFactory.getEarlyBeanReference(String, RootBeanDefinition, Object)，并将beanName与匿名的ObjectFactory添加到DefaultSingletonBeanRegistry#singletonFactories；beanName添加到DefaultSingletonBeanRegistry#registeredSingletons中，并从DefaultSingletonBeanRegistry#earlySingletonObjects中remove该beanName。
		！！！首先明确一个思路，就是凡进入getEarlyBeanReference的bean，必然是触发了循环依赖的bean
		AbstractAutowireCapableBeanFactory.getEarlyBeanReference(String, RootBeanDefinition, Object)会逐个调用实现了SmartInstantiationAwareBeanPostProcessor的bean，如AbstractAutoProxyCreator#getEarlyBeanReference，其会先调用getCacheKey根据beanClass和beanName获取缓存key，然后从缓存earlyProxyReferences中判断该bean是否已存在该beanName，若不存在，则将其加入earlyProxyReferences，并继续调用AbstractAutoProxyCreator.wrapIfNecessary(Object, String, Object)进行转换代理bean，这段可见aop代理部分的AbstractAutoProxyCreator.wrapIfNecessary(Object, String, Object)方法详解。
		该方法的意义在于，当循环依赖发生的时候，以防其他bean通过AbstractBeanFactory.doGetBean(String, Class<T>, Object[], boolean)中的第二步，DefaultSingletonBeanRegistry.getSingleton(String)中，从三级缓存singletonFactories#getObject中获取到的是原类的实例而非代理类的实例，因为如果这里获取到了原类的引用后，就无法继续获取代理的引用了。
	（7）定义exposedObject，并将（3）中构建的bean赋值给它，该值最终将作为doCreateBean的返回值返回
	（8）调用AbstractAutowireCapableBeanFactory.populateBean(String, RootBeanDefinition, BeanWrapper)填充beanDefinition的PropertyValues
	若入参bean包装——BeanWrapper为空
		（1）
			（1.1）bd的填充属性——mbd.getPropertyValues()不为空则抛出bean创建异常
			（1.2）bd的填充属性——mbd.getPropertyValues()为空，则无数据填充，直接return，方法结束
		（2）定义是否继续填充变量continueWithPropertyPopulation，默认为true，即需要填充，继续判断beanFactory#hasInstantiationAwareBeanPostProcessors即是否有InstantiationAwareBeanPostProcessor需要执行，若有且mbd#synthetic为false时，则逐个调用InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
			（2.1）若其中某一个InstantiationAwareBeanPostProcessor的该方法返回false，则标注continueWithPropertyPopulation为false，即马上被break出循环，方法结束，不再填充。
			（2.2）若都为true，则说明需要继续填充
		（3）以mbd.getResolvedAutowireMode()判断该bean的自动注入类型
			若为RootBeanDefinition.AUTOWIRE_BY_NAME或RootBeanDefinition.AUTOWIRE_BY_TYPE时，以MutablePropertyValues newPvs = new MutablePropertyValues(pvs)，创建MutablePropertyValues对象。
			然后，
			（3.1）RootBeanDefinition.AUTOWIRE_BY_NAME——调用AbstractAutowireCapableBeanFactory.autowireByName(String, AbstractBeanDefinition, BeanWrapper, MutablePropertyValues)
			该方法根据名称整理入参pvs，并通过DefaultSingletonBeanRegistry.registerDependentBean(String, String)将key-propertyName，value-beanName注册到dependentBeanMap、dependenciesForBeanMap中
			（3.2）RootBeanDefinition.AUTOWIRE_BY_TYPE——调用AbstractAutowireCapableBeanFactory.autowireByType(String, AbstractBeanDefinition, BeanWrapper, MutablePropertyValues)
			该方法根据类型整理入参pvs，并通过DefaultSingletonBeanRegistry.registerDependentBean(String, String)将key-propertyName，value-beanName注册到dependentBeanMap、dependenciesForBeanMap中 
			resolveDependency // TODO
			最后将新建的newPvs赋值于入参pvs，替换原填充属性
		(4)定义以下两个变量
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();——该beanFactory是否有InstantiationAwareBeanPostProcessor
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);——该bean的mbd#dependencyCheck不为DEPENDENCY_CHECK_NONE
			（4.1）若上述两个变量任一为真时，调用AbstractAutowireCapableBeanFactory.filterPropertyDescriptorsForDependencyCheck(BeanWrapper, boolean)获取PropertyDescriptor实例（该类为java.beans中的类），可读写指定类的指定变量的读写方法（getReadMethod、getWriteMethod、setReadMethod、setWriteMethod）还可通过读写该变量的值（setPropertyType(Class<?>)、getPropertyType）等等。
				// TODO（4.1.1）若hasInstAwareBpps为true，即有InstantiationAwareBeanPostProcessor执行时，逐个调用InstantiationAwareBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String)填充bean，当返回的pvs为空时，方法结束。
				该方法为实际注入bean的入口，如CommonAnnotationBeanPostProcessor(@Resource)、AutowiredAnnotationBeanPostProcessor(@Autowired)等
				// TODO（4.1.2）若needsDepCheck为true，调用AbstractAutowireCapableBeanFactory.checkDependencies(String, AbstractBeanDefinition, PropertyDescriptor[], PropertyValues)继续检查该bean的依赖（mbd#dependencyCheck）。
				方法内部逐个迭代PropertyDescriptor[]数组
		（5）调用AbstractAutowireCapableBeanFactory.applyPropertyValues(String, BeanDefinition, BeanWrapper, PropertyValues)将配置的PropertyValues解析并填充到BeanWrapper中。
			（5.1）其内部通过BeanDefinitionValueResolver.BeanDefinitionValueResolver(AbstractBeanFactory, String, BeanDefinition, TypeConverter)构建BeanDefinitionValueResolver实例，并调用BeanDefinitionValueResolver#resolveValueIfNecessary，逐个将propertyValue中的value进行转换，转换过程较复杂，会根据value的类型（有RuntimeBeanReference、RuntimeBeanNameReference、BeanDefinitionHolder、BeanDefinition、ManagedArray、ManagedList、ManagedSet、ManagedMap、ManagedProperties、TypedStringValue几种类型进行转换，常用的仅前几种）常用类型主要针对在BeanDefinitionParser.parse(Element, ParserContext)中生成的propertyValue引用进行解析，并转换成实际的beanValue实例引用。
			（5.2）将上述转换后的propertyValue加入到List<PropertyValue> deepCopy中，并转换成MutablePropertyValues(List<PropertyValue>)，最后通过PropertyAccessor.setPropertyValues(PropertyValues)将该propertyValues注入到bean中，完成对bean实例变量的填充。
		// TODO
		!!!AbstractBeanDefinition的DEPENDENCY_CHECK依赖检查规则：
		1、DEPENDENCY_CHECK_NONE——什么都不检查
		2、DEPENDENCY_CHECK_OBJECTS——只检查复杂类型的属性
		3、DEPENDENCY_CHECK_SIMPLE——只检查简单类型的属性，通过BeanUtils.isSimpleProperty(Class<?>)判断是否为简单类型
		4、DEPENDENCY_CHECK_ALL——什么属性都检查

	（9）调用AbstractAutowireCapableBeanFactory#initializeBean对bean进行各种初始化方法（如各种Aware、自定义的初始化方法、InitializingBean#afterPropertiesSet、BeanPostProcessor等，动态代理类的创建也是在这里完成，因而若经过如AnnotationAwareAspectJAutoProxyCreator、AsyncAnnotationBeanPostProcessor的后置方法postProcessAfterInitialization后，exposedObject将变成代理对象proxy$0）。

	（10）若（5）中的earlySingletonExposure为true，调用DefaultSingletonBeanRegistry#getSingleton(beanName, false)且第二个参数allowEarlyReference为false，表示不从三级缓存DefaultSingletonBeanRegistry#singletonFactories中获取ObjectFactory
	（11）若（10）即从一级缓存singletonObjects、二级缓存earlySingletonObjects中已获取到earlySingletonReference且不会空时
		！！！正常情况，在没有发生循环依赖的时候，此方法返回的一定是空，因为只有当外层的createBean以及更外层的getSingleton(String beanName, ObjectFactory<?> singletonFactory)的方法的最后，才会调用DefaultSingletonBeanRegistry.addSingleton(String, Object)将该bean加入singletonObjects，并移除earlySingletonObjects、singletonFactories。
		（1）当exposedObject == bean时，即exposedObject经过initializeBean处理后没有任何改变时，将earlySingletonReference赋值给exposedObject，由于earlySingletonReference是经过循环依赖从三级缓存移到二级缓存中的，经过getEarlyBeanReference后引用不会再改变了，所以与exposedObject相比是相对成熟的bean，所以应该替换原本的exposedObject
		（2）当exposedObject != bean时，代表exposedObject经过initializeBean后又被重新赋值了，且其在getEarlyBeanReference也获取到了引用，说明其已经被循环加载过了，所以这里的bean可能已经存在隐患了，所以之后可能抛出BeanCurrentlyInCreationException，// TODO

！！！关于singletonObjects、earlySingletonObjects、singletonFactories
1、singletonObjects：存放的都是已经实例化的完全体bean
2、earlySingletonObjects：只有在循环依赖发生时，即doGetBean直接调用getSingleton(String beanName)从三级singletonFactories获取到bean时，该bean才会存在于earlySingletonObjects中，同时singletonsCurrentlyInCreation中也一定包含该beanName，且当该bean创建完毕时，会在最外层的getSingleton(String beanName, ObjectFactory<?> singletonFactory)的方法的最后，才会调用DefaultSingletonBeanRegistry.addSingleton(String, Object)将该bean加入singletonObjects，并移除earlySingletonObjects、singletonFactories。
3、singletonFactories：存放的都是允许提前暴露、且未创建完毕的bean，即：
在earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName))为true时，
会将key-beanName，value-ObjectFactory放入。
存在于earlySingletonObjects、singletonFactories中的bean都是不完全bean，因而其beanName都会存在于singletonsCurrentlyInCreation中。

！！！一般而言，若二级缓存earlySingletonObjects和三级缓存singletonFactories中存在的bean，代表尚未完成初始化，则在singletonsCurrentlyInCreation一定存在该bean的beanName。
并且，一个类如果被创建代理多次，返回的代理类类型均相同、且实例也完全相同，具体可见java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class<?>[], InvocationHandler) // TODO

需要注意的是在AbstractBeanFactory#createBean过程中会先调用AbstractAutowireCapableBeanFactory.populateBean(String, RootBeanDefinition, BeanWrapper)填充beanDefinition的PropertyValues，然后再调用AbstractAutowireCapableBeanFactory#initializeBean对bean进行各种初始化方法（如各种Aware、自定义的初始化方法、InitializingBean#afterPropertiesSet、BeanPostProcessor等）。在获取了该bean实例后，还会调用AbstractBeanFactory#getObjectForBeanInstance
不论该bean的scope是单例、多例或其他任何值，之后都会调用getObjectForBeanInstance，该方法在内部经过如下判断：
		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
			return beanInstance;
		}
因而只有实现了FactoryBean的bean，且没以"&"开头时，才会继续执行下去，直到调用AbstractBeanFactory的父类FactoryBeanRegistrySupport#getObjectFromFactoryBean、#doGetObjectFromFactoryBean后，调用FactoryBean被重写的getObject返回其构造的特殊实例为止，到此此FactoryBean的getObject就代替了原类型bean了。
这里的执行是在实例化FactoryBean之后的，是在执行完AbstractAutowireCapableBeanFactory.doCreateBean后才执行的。所以容易该FactoryBean还实现了InitializingBean（如mybatis的MapperFactoryBean），那么其InitializingBean#afterPropertiesSet执行是在FactoryBean#getObject之前的。

7、方法执行至此，若已获取到了bean，且requiredType不为空，同时requiredType.isAssignableFrom(bean.getClass())又返回false（即requiredType不是bean.getClass()的父类），调用AbstractBeanFactory.getTypeConverter()获取类型转换器，并调用该转换器TypeConverter.convertIfNecessary(Object, Class<T>)进行类型转换，最终返回该bean。
// TODO 待补充
此处可结合FactoryBean初始化一起整理。

8、异常捕获

9、processDispatchResult

手动注册bean
可由BeanDefinitionRegistry#registerBeanDefinition(String, BeanDefinition)进行注册
（BeanDefinitionRegistry可由DefaultListableBeanFactory也可由ParseContext获取）

ParseContext
ReadContext-XmlReaderContext#getRegistry

shiro初始化
入口类——org.springframework.web.filter.DelegatingFilterProxy
#initFilterBean——targetBeanName未定义的情况下会以filterName进行赋值，然后调用#initDelegate，由于shiro.xml的启动顺序优先于该filter，故此时的Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);会成功获取到xml中配置的shiro的filter，即org.apache.shiro.spring.web.ShiroFilterFactoryBean。（ShiroFilterFactoryBean$SpringShiroFilter），同时由于ShiroFilterFactoryBean实现了FactoryBean，因而在
getBean时会调用其#getObject，最终调用到#createInstance，并返回一个AbstractFilter。然后由于web.xml中设置了targetFilterLifecycle为true，故会执行delegate#init，即执行AbstractFilter#init，开始shiro的初始化。
	protected Filter initDelegate(WebApplicationContext wac) throws ServletException {
		Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);
		if (isTargetFilterLifecycle()) {
			delegate.init(getFilterConfig());
		}
		return delegate;
	}

FactoryBean初始化（应用如SqlSessionFactoryBean、ShiroFilterFactoryBean等）
AbstractBeanFactory#doGetBean，会调用org.springframework.beans.factory.support.AbstractBeanFactory.transformedBeanName(String)对name进行解析，将name开头的所有"&"去除，并赋值给beanName，如此一来，name负责处理与factoryBean有关的bean获取，而beanName则用来获取所有其他bean。
AbstractBeanFactory#getObjectForBeanInstance（此方法会判断该bean是否实现了FactoryBean并调用BeanFactoryUtils.isFactoryDereference判断beanName是否以BeanFactory.FACTORY_BEAN_PREFIX即"&"开头，两者满足其一则会直接返回bean实例，否则调用实现的getObject并返回实例）
FactoryBeanRegistrySupport#getObjectFromFactoryBean
FactoryBeanRegistrySupport#doGetObjectFromFactoryBean实现了PrivilegedExceptionAction并重写了run，返回值为factory.getObject()，即FactoryBean的实现类的getObject

shiro——ShiroFilterFactoryBean——https://www.cnblogs.com/ljdblog/p/6237683.html
shiro的核心管理器ShiroFilterFactoryBean会创建DefaultFilterChainManager作为内部拦截链的管理器
DefaultFilterChainManager#addDefaultFilters添加默认的拦截器DefaultFilter到内部的filters中（Map<String, Filter>）
1， ShiroFilterFactoryBean#createFilterChainManager定义一个DefaultFilterChainManager对象
2， DefaultFilterChainManager#addDefaultFilters首先加载默认的filter并放入manager的filters中
3， manager.addFilter(name, filter, false);加载xml文件中定义的filter并放入manager的filters中
4， 以shiro的内部规则（DefaultFilterChainManager#toNameConfigPair）拆分filterChainDefinitions，DefaultFilterChainManager#addToChain，加载xml文件定义的url和filter映射关系
5， PathMatchingFilter#processPathConfig将映射关系解析为以url为键，NamedFilterList为值的键值对。
6， 在解析的过程中，对每个url和对应的过滤条件，都会放到对应filter的appliedPaths中（在PathMatchingFilter中定义）。
现在FilterChainManager的对象已经创建完毕，并且每个filter也已经实例化完毕。

PathMatchingFilterChainResolver
当请求过来时，先以PathMatchingFilterChainResolver#getChain调用#pathMatches迭代DefaultFilterChainManager#getChainNames内部存储的Set<pathPattern>逐个匹配requestURI，若匹配上了，则调用filterChainManager进行代理拦截，匹配不上则返回空。

autowired自动注入
AutowiredAnnotationBeanPostProcessor的无参构造自动添加了Autowired和Value为默认扫描的注解，并扫描项目是否存在Inject，若存在一并加入扫描范围。
同时内部包含2个内部类AutowiredFieldElement和AutowiredMethodElement分别处理字段和方法的注解。

spring——getBean——一图流——https://blog.csdn.net/zghwaicsdn/article/details/50910384

springmvc——request、session的@autowired线程安全问题——https://blog.csdn.net/zknxx/article/details/77917290
AbstractApplicationContext#refresh()
AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory)
AbstractRefreshableWebApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory)
WebApplicationContextUtils#registerWebApplicationScopes(ConfigurableListableBeanFactory, ServletContext)将调用beanFactory#registerResolvableDependency对每个scope进行注册，其实现就是DefaultListableBeanFactory，它会将每个入参以键值对的形式（其中key为注册的class接口如ServletRequest、ServletResponseHttpSession等，value为生产该class实例且实现了ObjectFactory的工厂类，其内部其实是通过RequestContextHolder的线程变量requestAttributesHolder实现）放入到其内部的ConcurrentHashMap——resolvableDependencies，这样在DefaultListableBeanFactory.findAutowireCandidates时会调用内部的resolvableDependencies以key获取value即实现了ObjectFactory的工厂类实例，通过AutowireUtils#resolveAutowiringValue，判断该实例是否实现了ObjectFactory，接着判断是否支持序列化以及是否为接口，若满足，则通过jdk动态生成代理实例（Proxy.newProxyInstance(requiredType.getClassLoader(), new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))），否则调用实现类的getObject获取对应的scope实例，获取过程也就是调用RequestContextHolder#currentRequestAttributes获取ServletRequestAttributes继而获取request、response或session，并将该实例以key、value的形式放入到LinkedHashMap中（其中key为通过ObjectUtils转换的带"@"的字符串，value为该实例），并返回。
也正是由于其是一个代理对象，当我们调用request、response或session的时候会触发ObjectFactoryDelegatingInvocationHandler#invoke会调用其内部的objectFactory#getObject返回其实例，而getObject实质也是通过RequestContextHolder获取的线程变量，所以这里返回的request、response或session是提前设置在线程变量中的安全的对象。

FrameworkServlet#processRequest中会通过FrameworkServlet.buildRequestAttributes(HttpServletRequest, HttpServletResponse, RequestAttributes)构建ServletRequestAttributes实例（包含request和response），而后将该对象通过FrameworkServlet.initContextHolders(HttpServletRequest, LocaleContext, RequestAttributes)封装成线程变量RequestContextHolder#setRequestAttributes将request放入线程变量，即inheritableRequestAttributesHolder和requestAttributesHolder中。


org.springframework.web.SpringServletContainerInitializer位于spring-web包的META-INF/services中，在容器启动时会自动执行其onStartup方法，其内部会获取SpringServletContainerInitializer#initializers即WebApplicationInitializer集合，然后逐个调用每个的onStartup方法，免配置的SpringMvc就是基于AbstractAnnotationConfigDispatcherServletInitializer，也就是实现了WebApplicationInitializer接口的自动化配置类。

spring内部的工具类
ObjectUtils
ClassUtils
AnnotationUtils
ReflectionUtils
BeanUtils
BeanFactoryUtils——获取bean
BeanDefinitionReaderUtils——注册bean

/******************************************************************/

SpringBoot

SpringBootAutoConfigure

spring-boot-autoconfigure作用及实现方式：
以spring-boot约定优于配置的形式，以用户的配置加载部分bean，在用户没有自定义配置时，则以缺省值代替，以达到尽可能少的配置达到相同的效果。

1、以@SpringBootApplication注解的类路径的包或子包为路径
2、配置META-INF/spring.factories下的org.springframework.boot.autoconfigure.EnableAutoConfiguration=\xxx.xxx.XxxAutoConfiguration
3、配置@EnableXXX注解，并以@Import形式导入xxx.xxx.XxxAutoConfiguration自定义注解类

/******************************************************************/

/******************************************************************/

Mybatis

Mybatis对mapper类的扫描
MapperScannerConfigurer通过实现BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry创建了mybatis自定义的ClassPathMapperScanner实例，并用该实例扫描了basePackage，将所有的mapper转换为了BeanDefinition。

mybatis——https://blog.csdn.net/nmgrd/article/details/54608702
# 与 $——https://blog.csdn.net/wo541075754/article/details/54292751
sql拼接与预编译，$在预编译阶段之前已经被替换成了具体的参数，而#在预编译阶段只是将参数替换成了占位符?，然后经过数据库底层的编译，这时即使再传入' or 1 = 1'之类的参数，数据库也只会当做参数，而不会当做指定来进行处理了。数据库执行sql语句可以理解为按照关键字来编译sql语句，而预编译后数据库肯定就不再重复编译了，所以这时再传什么 AND, OR都只会当成普通字符串来处理。

Mybatis插件——https://blog.csdn.net/top_code/article/details/55520948
实现org.apache.ibatis.plugin.Interceptor，使用@Signature指定拦截的类、方法签名

TypeHandlerRegistry——mybatis类型处理注册器，构造方法中注册了默认的类型处理器，也可以自定义处理器，继承TypeHandler，并配置到sqlSessionFactory的typeHandlersPackage中即可。

/******************************************************************/

JAVA Core

默认：
新生代：老年代=1:2
eden：survive=8:1:1

类加载顺序
加载——验证——准备——解析——初始化

类加载器——https://blog.csdn.net/studyvcmfc/article/details/7720322
双亲委派——https://www.cnblogs.com/wxd0108/p/6681618.html
类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。

string
https://www.zhihu.com/question/57697842
关于String#intern()——https://blog.csdn.net/u013366617/article/details/83618361
1、首先intern不会改变对象引用
2、两个new String()相加时（或append），不会在常量池中添加常量，只会在堆中创建对象和字面量

tomcat下的应用——WebappClassLoader继承自URLClassLoader，部署到tomcat的类文件基本都由其加载
jdk核心类——BootstrapClassLoader——内部实现，非java实现，也非ClassLoader的子类，负责加载rt.jar下的类
扩展库类——ExtClassLoader——继承自URLClassLoader，负责加载ext下的类
类路径下的类classpath——AppClassLoader——继承自URLClassLoader

双重检查单例与其缺陷：
https://blog.csdn.net/a_842297171/article/details/79316591
volatile保证可见性、禁止指令重排序
指令重排序是JVM对语句执行的优化，只要语句间没有依赖，那JVM就有权对语句进行优化。
单线程的情况下，指令重排序没有线程安全问题，但是在多线程的情况下，线程的共享变量由于会同时被多个线程读取、修改，因而一个线程在读取共享变量后还未来得及修改时，是可能会被其他线程读取到这个无效的值的，因而多线程情况下，指令重排序存在线程安全问题。
①分配空间给对象
②在空间内创建对象
③将对象赋值给引用对象

设计模式：
1、在无法改变既定类的结构、方法时，可使用访问者模式，以自定义类加载既定类，然后在自定义类中添加逻辑操作既定类，既达到实现效果，又不改变原类。

ArrayList——https://www.cnblogs.com/ShanHeDiao/p/4402030.html
默认初始长度10，每次扩容1.5倍，10-16-25...，每次添加元素，先判断是否超长度，若超则先扩容，扩容方式为：
int oldCapacity = elementData.length;
int newCapacity = oldCapacity + (oldCapacity >> 1);//新容量扩大到原容量的1.5倍，右移一位相关于原数值除以2。
向ArrayList添加对象时，原对象数目加1如果大于原底层数组长度，则以适当长度新
建一个原数组的拷贝，并修改原数组，指向这个新建数组。原数组自动抛弃（java垃圾回收机制会自动回收）。size则在向数组添加对象，自增1。

LinkedHashMap——https://blog.csdn.net/justloveyou_/article/details/71713781
HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap的元素存取过程基本与HashMap基本类似，只是在细节实现上稍有不同。当然，这是由LinkedHashMap本身的特性所决定的，因为它额外维护了一个双向链表用于保持迭代顺序。此外，LinkedHashMap可以很好的支持LRU算法，笔者在第七节便在LinkedHashMap的基础上实现了一个能够很好支持LRU的结构。

HashMap初始容量与扩容——https://blog.csdn.net/moakun/article/details/80494253
初始容量为入参initialCapacity（默认为16）的下一个2的整数幂，这么做的目的是充分利用空间。假设数组的长度是17，那么掩码的值就是16（数组长度-1）。16的二进制表示是0…010000，这样对于任何值H来说，“H & 16”的结果就是16或者0。这意味着长度为17的数组只能应用到两个桶上：一个是0，另外一个是16，这样不是很有效率。但是如果你将数组的长度设置为2的幂值，例如16，那么按位索引的工作变成“H & 15”。15的二进制表示是0…001111，索引公式输出的值可以从0到15，这样长度为16的数组就可以被充分使用了。
每次put的时候，会先计算key的hash值，由此算出i = (n - 1) & hash，其中n为2的整数幂，这样，经过"&"计算后，所获得的索引必然小于n-1，且分布会相对均匀，所以能充分利用数组的容量。

n |= n >>> 1;  ——00000011 | 00000001 = 00000011
n |= n >>> 2;  ——00000011 | 00000000 = 00000011
n |= n >>> 4;  ——00000011 | 00000000 = 00000011
n |= n >>> 8;  ——00000011 | 00000000 = 00000011
n |= n >>> 16; ——00000011 | 00000000 = 00000011
这么做的目的在于，通过"|"运算，可以把第一个非"0"位开始之后的所有位都替换成"1"，即0001111111形式，只要再进行"+1"操作后，即可得到最接近的那个二次幂，再通过"&"运算与"n-1"进行运算，使原数字的第一个非"0"位开始每一个位均有可能是"1"或者"0"，即可将计算结果相对平滑的分布在每一个索引中。

<<、>>、>>>
<<带符号左移
>>带符号右移
>>>无符号右移

charset编码集
utf-8
gbk
unicode

队列
https://www.cnblogs.com/tadckle/p/3530084.html

类加载
https://blog.csdn.net/chenge_j/article/details/72677766

jvm堆、新生代、老年代——https://www.cnblogs.com/yydcdut/p/3959711.html
eden、survive比例为8:1:1，新生代、老年代比例默认为1:2

java的队列 Queue（LinkedList）——https://www.cnblogs.com/skywang12345/p/3308807.html

Thread
join——由线程实例调用，调用后，当前执行的线程会被阻塞，直到调用的线程实例执行完成后，当前线程才会执行下去。
yield——线程的静态方法，暂停当前正在执行的线程对象，并执行其他线程。

ThreadLocal——https://blog.csdn.net/zhailuxu/article/details/79067467
ThreadLocalMap.Entry继承自WeakReference<ThreadLocal<?>>，其中，在其构造中，key被直接传递到了Reference，因而其key是一种弱引用，当key所引用的threadLocal被释放时，当调用threadLocal#get、set、remove时，也会销毁key为null的value，进而一定程度上避免了内存泄漏
内存泄漏，指的是一个线程执行完毕后，由于线程池的存在，该线程并未被销毁，而是重新被放入了线程池，故其map即ThreadLocalMap未被释放，若该map的key即threadLocal未进行remove，则会继续残留在该线程中。
关于强引用、软引用、弱引用、虚引用：https://www.jianshu.com/p/017009abf0cf

static 内部类（会被编译成新的.class文件，文件名为其外部类名+"$"+内部类名）
1、只能定义在public类内
2、外部类可实例化该类对象
3、内部方法仍为实例方法，也可定义静态方法

public类外class（会被编译成新的.class文件，文件名为新的类名）
1、可定义可实例化

public类内class（会被编译成新的.class文件，文件名为其外部类名+"$"+内部类名）
1、可定义可实例化，可实例化仅限在其外部类内
在外部类内，且其他内部类内，可定义不可实例化
在外部类外，不可定义不可实例化

java.beans包
Beans
PropertyDescriptor
Introspector

PropertyDescriptor
PropertyEditor
PropertyEditorRegistrySupport继承自PropertyEditor

反射
public Method[] getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。
public Method[] getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。

AbstractQueuedSynchronizer
https://www.cnblogs.com/leesf456/p/5350186.html
继承自AbstractOwnableSynchronizer，该类可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用。

Debug
1、展示的变量都是调用该对象所属类的toString()方法
2、静态变量的值不会出现在该对象的属性列表中

JDK的动态代理都是通过使用Proxy去实现所要代理的类的接口实现代理功能的，最后的实际类型都是Proxy，但其内部的实例变量h也就是InvocationHandler会被赋值为实际实现了InvocationHandler接口的切入增强类。

动态代理
生成的代理类继承自Proxy，且与目标类实现自同一接口，代理类字节码中，通过以下方式获取代理方法：
通用方法：Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
自定义方法：m3 = Class.forName("com.demo.test.proxy.ITarget").getMethod("test", new Class[] { Class.forName("java.lang.String") });
然后统一重写实现自父接口的方法，具体代理实现逻辑以equals为例：
  public final boolean equals(Object paramObject)
    throws 
  {
    try
    {
      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();
    }
    catch (Error|RuntimeException localError)
    {
      throw localError;
    }
    catch (Throwable localThrowable)
    {
      throw new UndeclaredThrowableException(localThrowable);
    }
  }
可通过以下方式设置生成代理类字节码文件：
System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");

二叉树
在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个叶子节点，至多有2k-1个节点。

/******************************************************************/

JAVA程序检查
System.setSecurityManager(new SecurityManager());启用权限检查
AccessController的doPrivileged使用——https://blog.csdn.net/yekong1225/article/details/81011819
透过AccessController深入了解Java安全模型——https://www.jianshu.com/p/81985bc2bfa3

/******************************************************************/

/******************************************************************/

JVM

java以命令行程序执行java程序
javaw以窗口程序执行java程序，是一个win32的windows gui程序
javac将.java编译成字节码.class
javap反编译.class字节码
javah生成实现本地方法所需的 C 头文件和源文件

/******************************************************************/

/******************************************************************/

SQL

mysql replace into
代替insert into，唯一索引存在则进行更新，否则进行插入，原子操作

show variables like '%%';可查询数据库配置，如'autocommit'-事务提交设置，'engine'-数据库引擎

select @@tx_isolation;查看当前会话隔离级别

select @@global.tx_isolation;查看系统当前隔离级别

事务隔离级别的设置
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]

show variables like '%slow_query%';

set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable | Serializable;修改事务隔离级别——https://blog.csdn.net/guangyuj/article/details/70313502

相关variables的配置在performance_schama中有相关记录

mysql索引——https://www.cnblogs.com/shijianchuzhenzhi/p/6383117.html

mysql优化——https://www.cnblogs.com/sunshine-2015/category/987731.html

mysql锁机制
1、for update会阻塞更新、以及其他for update事务，但不会阻塞普通的查询。

insert into table_name1 select * from table_name2(table_name1全表锁，table_name2逐步锁，根据where条件)


/******************************************************************/

前端相关


js相关：
真值假值——在JavaScript中，Truthy(真值)指的是在Boolean上下文中转换后的值为真的值。所有值都是真值，除非它们被定义为 falsy (即， 除了false，0，“”，null，undefined和NaN 外)。——https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy

es6
https://www.jianshu.com/p/287e0bb867ae

mvvm——https://www.jianshu.com/p/a5f2b2b45618

vue相关
vuex——https://segmentfault.com/a/1190000007516967#articleHeader3

vue项目
知乎——https://www.zhihu.com/question/37984203
音乐搜索播放应用——https://github.com/Sioxas/vue-music/
重构CnodeJS社区——https://github.com/shuiRong/VueCnodeJS

vue快速入门
https://www.cnblogs.com/rik28/p/6024425.html
http://www.jb51.net/article/111658.htm


/******************************************************************/

其它

netty学习
https://www.cnblogs.com/azcode/p/6876882.html
http://wiki.jikexueyuan.com/project/netty-4-user-guide/realize-chat.html
https://www.jianshu.com/p/b9f3f6a16911
netty能做什么——https://www.zhihu.com/question/24322387
Netty源码——https://www.cnblogs.com/sunshine-2015/category/1259776.html

fastdfs——https://www.cnblogs.com/Leo_wl/p/6731647.html

slf4j log4j
http://www.importnew.com/7450.html
http://blog.csdn.net/tanga842428/article/details/52924883
http://itindex.net/detail/48502-log-%E6%97%A5%E5%BF%97-%E6%A1%86%E6%9E%B6

logback启动原理——http://blog.csdn.net/MrZhangXL/article/details/68489565
StaticLoggerBinder

tomcat加载过程
http://www.cnblogs.com/xing901022/p/4574961.html


书籍、源码
https://www.cnblogs.com/rainy-shurun/p/6564407.html

netty——dubbo默认的通信组件
https://www.jianshu.com/p/c5068caab217


单独部署一台文件服务器，以避免将来集群部署应用时，文件路径读取的问题。
Load Balance（负载均衡）与High Available（高可用）

部署相关
http://www.importnew.com/27838.html#comment-639983

jenkins
https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000

工具类
google guava——https://www.cnblogs.com/SummerinShire/p/6054983.html
apache common lang3


淘宝前后端分离解决方案——http://2014.jsconf.cn/slides/herman-taobaoweb/index.html

http://blog.csdn.net/jinbiao520/article/details/9903193


坑——http://www.iteye.com/topic/1131191

设计模式——https://www.cnblogs.com/foryang/p/5849402.html
装饰模式与代理模式——https://www.cnblogs.com/jaredlam/archive/2011/11/08/2241089.html
装饰模式着重于控制访问权限，在代理类内部就决定了运行时调用的真实对象，而装饰模式着重于增强业务逻辑，在类外部通过构造方法（或set）方法注入实际的方法调用者。

高并发
https://blog.csdn.net/DreamWeaver_zhou/article/details/78587580
https://www.cnblogs.com/lr393993507/p/5909804.html
高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。

提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。

互联网分层架构中，各层次水平扩展的实践又有所不同：

（1）反向代理层可以通过“DNS轮询”的方式来进行水平扩展；

（2）站点层可以通过nginx来进行水平扩展；

（3）服务层可以通过服务连接池来进行水平扩展；

（4）数据库可以按照数据范围，或者数据哈希的方式来进行水平扩展；

各层实施水平扩展后，能够通过增加服务器数量的方式来提升系统的性能，做到理论上的性能无限。

redis RDB AOF——https://blog.csdn.net/m0_38110132/article/details/76906422

分库分表——https://blog.csdn.net/u011277123/article/details/78358808
我们将常用的（id, name, price, company）字段放在一个表中，而不常用的（）字段放在拓展表中，那我们查询时优先查询常用字段，在有必要时才查询拓展字段。可以有效的提高效率，同时减少字段后我们在一个表中可以容纳的数据数量也提高了。

秒杀业务——https://blog.csdn.net/yd201430320529/article/details/70173178
秒杀业务架构优化之路——http://www.infoq.com/cn/articles/flash-deal-architecture-optimization

高并发请求：
1、客户端拦截：js控制按钮不可用，拦截大部分用户
2、站点层拦截，通过uid以及redis集群，为每个uid的请求设置访问频率


/******************************************************************/

Tomcat源码解析

1、概念
org.apache.catalina.connector.Connector继承自Lifecycle，设置端口、协议、Scheme（https or http）
org.apache.catalina.Container继承自Lifecycle

StandardServer——继承自LifecycleMBeanBase实现Server
StandardService——继承自LifecycleMBeanBase实现Service

线程相关：
org.apache.tomcat.util.net.AbstractEndpoint.createExecutor()
org.apache.catalina.core.StandardThreadExecutor
org.apache.tomcat.util.threads.TaskThread.WrappingRunnable实现了Runnable，并在内部存储了Runnable实例wrappedRunnable，其run实质上为调用wrappedRunnable.run()

容器相关：
Engine——StandardEngine、EngineConfig
Host——StandardHost、HostConfig
Context——StandardContext、ContextConfig
Wrapper——StandardWrapper

需要注意的是以上类除Catalina外均继承自LifecycleMBeanBase，以此进行统一的生命周期管理。

org.apache.catalina.startup.HostConfig.beforeStart()读取以下两个路径的项目
org.apache.catalina.startup.HostConfig.configBase——conf\${engineName}\${hostName}
org.apache.catalina.startup.HostConfig.appBase——webapps

配置相关：
org.apache.tomcat.util.res.StringManager——读取各个包下的LocalStrings.properties

安全相关：
org.apache.catalina.security.SecurityUtil

2、启动
Bootstrap#main启动
调用自身的start，再反射调用Catalina#start
调用StandardServer#start-#startInternal
调用StandardService#start-#startInternal
调用内部container.start，即StandardEngine#start-#startInternal，调用父类org.apache.catalina.core.ContainerBase.startInternal()通过线程池startStopExecutor逐个启动线程


StandardContext.startInternal()——通过findChildren()，迭代出所有Wrapper，并逐个判断child.getState().isAvailable()返回false则启动该wrapper
LifecycleBase.fireLifecycleEvent(String, Object)
LifecycleSupport.fireLifecycleEvent(String, Object)
ContextConfig.lifecycleEvent(LifecycleEvent)
ContextConfig.configureStart()
ContextConfig.webConfig()
WebXml.configureContext(Context)

StandardContext#startInternal从org.apache.catalina.core.StandardContext.initializers中获取SpringServletContainerInitializer并逐个调用其onStartup
org.springframework.web.SpringServletContainerInitializer

设置协议
org.apache.catalina.startup.ConnectorCreateRule.begin(String, String, Attributes)
org.apache.catalina.connector.Connector.Connector(String)
org.apache.catalina.connector.Connector.setProtocol(String)通过AprLifecycleListener.isAprAvailable()判断系统是否能启用apr方式


org.apache.catalina.startup.ContextConfig.beforeStart()
org.apache.catalina.util.ContextName.ContextName(String, String)设置应用的path

WebXml实例可通过toXml()，通过StringBuilder，拼装整个xml

统一实现对应的StandardEngine、StandardHost、StandardWrapper，并继承自ContainerBase，ContainerBase继承自LifecycleMBeanBase并实现Container
Engine——Host——Context——Wrapper（Servlet）（由wrapper对servlet进行包装，内部是一对一的关系）
并且每一个Container内部都拥有一个继承自ContainerBase的Container——parent，并由wrapper、context、host、engine顺序由下而上获取。


3、处理请求：根据bio、nio、apr决定org.apache.coyote.http11.Http11NioProtocol.Http11ConnectionHandler

BIO：
org.apache.tomcat.util.net.JIoEndpoint.SocketProcessor.run()
org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler.process(SocketWrapper<S>, SocketStatus)


NIO：
org.apache.tomcat.util.net.NioEndpoint.SocketProcessor.run()
org.apache.coyote.http11.Http11NioProtocol.Http11ConnectionHandler.process(SocketWrapper<S>, SocketStatus)


APR:
org.apache.tomcat.util.net.NioEndpoint.SocketProcessor.run()
org.apache.coyote.http11.Http11AprProtocol.Http11ConnectionHandler.process(SocketWrapper<S>, SocketStatus)

后续请求处理过程相同：
org.apache.catalina.core.StandardEngineValve.invoke(Request, Response)

org.apache.catalina.core.StandardHostValve.invoke(Request, Response)
org.apache.catalina.core.StandardContextValve.invoke(Request, Response)
org.apache.catalina.core.StandardWrapperValve.invoke(Request, Response)

默认日志记录：
org.apache.catalina.core.ContainerBase.logAccess(Request, Response, long, boolean)
org.apache.catalina.core.AccessLogAdapter.log(Request, Response, long)


/******************************************************************/

Mybatis

初始化
（1）
org.mybatis.spring.SqlSessionFactoryBean实现了org.springframework.beans.factory.FactoryBean<SqlSessionFactory>
内部通过实现InitializingBean#afterPropertiesSet进行初始化，调用org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory()构建sqlSessionFactory，并配置org.apache.ibatis.session.Configuration，内部包括mybatis-config.xml的一些设置，都会被设置到这个实例中，并最后通过org.apache.ibatis.session.SqlSessionFactoryBuilder.build(Configuration)完成sqlSessionFactory的初始化。
如会实例化Environment(this.environment, this.transactionFactory, this.dataSource)其中environment默认为SqlSessionFactoryBean.class.getSimpleName()，而transactionFactory如果没有配置默认为SpringManagedTransactionFactory
这里会加载配置到Configuration中，然后通过SqlSessionFactoryBuilder.build(Configuration)构造DefaultSqlSessionFactory(Configuration)，并将Configuration作为实例变量赋值给它，DefaultSqlSessionFactory很重要，因为每次获取的sqlSession都是通过其构造的，在构造的时候会把Configuration传递给sqlSession。

org.mybatis.spring.mapper.MapperFactoryBean<T>，其泛型<T>就是对应每个mapper具体的类型，故每个mapper最终在获取的时候都会调用其MapperFactoryBean.getObject()方法获取对应mapper的代理类，大致过程为获取sqlSession，获取configuration，获取mapperRegistry，以MapperProxyFactory构建实现了InvocationHandler的MapperProxy<T>作为具体mapper的代理类返回。
其内部有两个实例变量：
1、Class<T> mapperInterface代表具体的mapper的class
2、boolean addToConfig // TODO 默认为true
上述的getMapper最终获取到的mapper都是org.apache.ibatis.binding.MapperProxy<T>代理类

在ClassPathMapperScanner.processBeanDefinitions(Set<BeanDefinitionHolder>)中通过definition（MapperProxy）即AbstractBeanDefinition.getConstructorArgumentValues()获取构造器，并以ConstructorArgumentValues.addGenericArgumentValue(Object)的方式将definition作为构造器的入参放入，即MapperFactoryBean.MapperFactoryBean(Class<T>)（mapperInterface以实例变量的形式保存在MapperFactoryBean中），使得之后获取该mapperBean实例的时候调用getObject可以以该mapperInterface为入参，从sqlSession中获取对应的mapper代理类。

// TODO

（2）org.mybatis.spring.mapper.MapperScannerConfigurer继承自org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor
首先通过实现InitializingBean#afterPropertiesSet完成校验
而后通过BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)完成扫描bean工作
org.mybatis.spring.mapper.ClassPathMapperScanner继承自org.springframework.context.annotation.ClassPathBeanDefinitionScanner
经由org.springframework.context.annotation.ClassPathBeanDefinitionScanner.scan(String...)后通过记录scan前后的this.registry.getBeanDefinitionCount()得到当前scanner扫描到的总bean数并返回
ClassPathMapperScanner通过重写父类的doScan(String...)做了一下个性化定制，而后继续调用父类的org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(String...)完成主要的扫描工作
而被扫描出来的bean会通过ClassPathMapperScanner.processBeanDefinitions(Set<BeanDefinitionHolder>)再经过一次处理，如加上propertyValues-addToConfig
被org.mybatis.spring.mapper.MapperScannerConfigurer扫描到的mapper在调用时会被JdkDynamicAopProxy统一代理


处理方法：
org.apache.ibatis.binding.MapperProxy<T>
1、#cachedMapperMethod(Method)通过缓存一个Map<Method, MapperMethod>methodCache对象，以Method、MapperMethod为键值对存入该map中，之后每次直接获取使用。
2、#invoke(Object, Method, Object[])反射调用的地方，也是实际调用MapperMethod#execute的地方
	（1）首先会判断method的class类型，若为Object，则会直接反射调用该方法，否则继续执行。一般而言，返回值都是false。
	（2）而后通过判断method是否为jdk8的新特性的default方法，判断的方式为：
		((method.getModifiers() & (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC)
        && method.getDeclaringClass().isInterface()
	Modifier：
	PUBLIC（1）、PRIVATE（2）、PROTECTED（4）、STATIC（8）、FINAL（16）、SYNCHRONIZED（32）、VOLATILE（64）
	TRANSIENT（128）、NATIVE（256）、INTERFACE（512）、ABSTRACT（1024）、STRICT（2048）
	因此，以上方法就变为
	((method.getModifiers() & (2^10 | 2^0 | 2^3)) == 1)
	        && method.getDeclaringClass().isInterface()
	即method为public，且method的class为interface，故一般而言，返回值都是false。方法继续执行。
	（3）调用org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(Method)以Method从缓存中获取MapperMethod，获取不到则进行实例化，然后放入缓存map
	其中，实例化过程分两步分别实例化MapperMethod的两个成员变量SqlCommand和MethodSignature
		1、SqlCommand(Configuration configuration, Class<?> mapperInterface, Method method)
			封装type和name
			会先以Configuration.hasStatement(String)判断是否已缓存了MappedStatement，
				若存在则type=ms.getId、name=ms.getSqlCommandType
				若不存在，则继续判断入参mapperInterface是否等于method.getDeclaringClass()，若不等于则继续以method.getDeclaringClass()+"."+methodName为key继续获取MappedStatement，若获取到了则继续第一步的操作
				若上述条件都没匹配上，即ms依然为空时，则判断方法是否含有@Flush注解，存在则手动赋值name=null，type=SqlCommandType.FLUSH

				注：org.apache.ibatis.session.Configuration.mappedStatements以键值对形式维护了一个Map<String, MappedStatement>，key为方法的全限定名，value为MappedStatement，在mybatis初始化时即完成加载了，
			//TODO MappedStatement介绍
			org.apache.ibatis.session.Configuration.mappedStatements以键值对形式维护了一个Map<String, MappedStatement>，key为方法的全限定名，value为MappedStatement
			org.apache.ibatis.mapping.MappedStatement
			org.apache.ibatis.mapping.MappedStatement.sqlSource#getBoundSql用以获取BoundSql
			
		2、MethodSignature(Configuration configuration, Class<?> mapperInterface, Method method)
			内部参数赋值如下：
			// TODO
			returnType = ;
			returnsVoid = void.class.equals(this.returnType);
			returnsMany = (configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray());
			returnsCursor = Cursor.class.equals(this.returnType);
			returnsMap = (this.mapKey != null);
			this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);
      		this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);
      		this.paramNameResolver = new ParamNameResolver(configuration, method);
	（4）调用org.apache.ibatis.binding.MapperMethod.execute(SqlSession, Object[])进行执行具体的CRUD

org.apache.ibatis.binding.MapperMethod.execute(SqlSession, Object[])逐个判断SqlCommand#type是CRUD中的哪个
不论是CRUD的哪个，都会通过MapperMethod.MethodSignature.convertArgsToSqlCommandParam(Object[])进行参数绑定，
而后调用org.apache.ibatis.reflection.ParamNameResolver.getNamedParams(Object[])
若是简单类型，且长度为1则直接返回简单类型数值
若是多个String，会封装一个Map作为返回值，内部以键值对存储了参数名：参数值，同时还会以"param*"为Key，参数值为Value存储一份

org.apache.ibatis.binding.MapperMethod内部封装了两个对象
1、org.apache.ibatis.binding.MapperMethod.SqlCommand内部封装了以下两个对象
	（1）sql的CRUD的枚举类型SqlCommandType
	（2）String类型的方法的全限定名

2、org.apache.ibatis.binding.MapperMethod.MethodSignature
内部封装了boolean类型的returnsMany、returnsMap、returnsVoid、returnsCursor、Class<?>类型的returnType（即返回值）、ParamNameResolver类型（存储了一个常量"param"、"java.lang.reflect.Parameter"以及反射得到的两个Method——"getName"和"getParameters"）的paramNameResolver等

判断完CRUD的方法后，根据CRUD类型，最后都会由实现了org.apache.ibatis.session.SqlSession的org.mybatis.spring.SqlSessionTemplate进行统一处理，而实际上这个类内部也只是内部存储了sqlSessionProxy以代理同样实现了SqlSession的org.apache.ibatis.session.defaults.DefaultSqlSession。
实际上SqlSessionTemplate在实例化的构造方法中就将成员变量sqlSessionProxy赋值为由Proxy#newProxyInstance创建的代理对象（由实现了java.lang.reflect.InvocationHandler（JDK代理的方式）的内部类org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor完成增强）
这样在SqlSessionTemplate调用select、insert等方法时，实际是以代理对象sqlSessionProxy调用，而sqlSessionProxy又是被SqlSessionInterceptor代理的对象，因而这时实际调用的方法为SqlSessionInterceptor#invoke即代理对象的代理方法，该方法内部会先获取同样实现了SqlSession的DefaultSqlSession，而后以DefaultSqlSession对象调用其内部的同名方法。
DefaultSqlSession会调用内部的实例变量executor，因而org.apache.ibatis.executor.Executor才是最后实际调用JDBC操作数据库的核心类

总结（调用规则）：
1、以MapperFactoryBean的构造器MapperFactoryBean(Class<T>)根据实际类型调用MapperFactoryBean#getObject
2、SqlSessionDaoSupport.getSqlSession()——获取到的实为SqlSessionTemplate
3、SqlSession.getMapper(Class<T>)——实为SqlSessionTemplate#getMapper(Class<T>)
4、DefaultSqlSession.getMapper(Class<T>)实际是调用内部的Configuration.getMapper(Class<T>, SqlSession)
5、而Configuration.getMapper实际为调用内部的MapperRegistry.getMapper(Class<T>, SqlSession)
6、MapperRegistry.getMapper第一次使用jdk的代理MapperProxyFactory.newInstance(SqlSession)，这个方法会根据mapperInterface的class实例化代理类
到此，代理类就获取完成了

注：SqlSessionTemplate内部有sqlSessionProxy代理类同样实现了SqlSession，其由SqlSessionInterceptor完成增强代理（依然是jdk动态代理），所有SqlSessionTemplate的执行实际上都由sqlSessionProxy执行，即SqlSessionInterceptor完成代理，而具体代理的过程事实上是获取DefaultSqlSession进行实际方法调用。

所以这里一共使用了两次jdk的动态代理：
1、一个是MapperRegistry.getMapper通过MapperProxyFactory.newInstance由MapperProxy完成增强
2、还一个是SqlSessionTemplate通过内部的sqlSessionProxy由SqlSessionInterceptor完成增强


关于org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor.invoke(Object, Method, Object[])：
1、这里的设计很奥妙，由于SqlSession的内部定义的sql操作方法相当多，且每次都需要获取、关闭sqlSession、反射调用方法的前后还涉及事务的提交、回滚，所以这里使用了jdk的动态代理，完成了对公用操作的封装，并利用反射调用实现了每个CRUD方法）
2、这里获取与关闭sqlSession均借助于SqlSessionUtils实现
org.mybatis.spring.SqlSessionUtils用于开启、释放、关闭sqlSession的工具类，内部通过Spring的org.springframework.transaction.support.TransactionSynchronizationManager进行线程安全的传递线程实例sqlSession。

SqlSessionUtils#getSqlSession用于获取线程变量，主要通过TransactionSynchronizationManager获取SqlSessionHolder，然后调用本地#sessionHolder获取线程变量sqlSession，若获取不到则调用SqlSessionFactory.openSession(ExecutorType)即DefaultSqlSessionFactory打开sqlSession，然后调用#registerSessionHolder将其放入线程变量中。
SqlSessionUtils#closeSqlSession方法通过判断入参sqlSession与获取到的sqlSession是否一致，一致则说明是同一个线程，进行release，若不一致，说明非同一个sqlSession，则将其关闭，这里主要是设计mybatis一级缓存的处理，一旦关闭了sqlSession，那么该次的一级缓存立即消失了。
注：这里对sqlSession是否需要关闭的判断使用了org.mybatis.spring.SqlSessionHolder，这个类是mybatis自己的，继承自spring的org.springframework.transaction.support.ResourceHolderSupport，而其父类ResourceHolderSupport中定义了两个方法#requested和#released，这两个方法将直接操作其内部的实例变量referenceCount，requested会自增，released则自减，同时也可以通过判断该值是否大于零实现isOpen。这样一来在获取sqlSession时，该值自增，释放sqlSession时，该值会自减，也就能判断何时能释放sqlSession、何时能关闭sqlSession了。
参考——SqlSessionHolder——https://www.cnblogs.com/chihirotan/p/6592759.html
除此之外，这里还定义了一个私有内部类org.mybatis.spring.SqlSessionUtils.SqlSessionSynchronization，其继承自spring的org.mybatis.spring.TransactionSynchronizationAdapter，分别重写了事务提交前后的三个动作，分别是beforeCommit（提交前）、beforeCompletion（完成前）和afterCompletion（完成后），在SqlSessionUtils.registerSessionHolder注册holder的时候，通过sessionFactory获取Configuration，继而获取Environment，并通过其获取transactionFactory，判断该事务管理器是否是SpringManagedTransaction，也就是Spring管理事务，若是则会调用TransactionSynchronizationManager#registerSynchronization(TransactionSynchronization)实例化SqlSessionSynchronization并放入。
该同步管理器TransactionSynchronizationManager会调用getSynchronizations()获取所有注册的同步器，在事务结束的时候（//TODO 具体时机）调用之前重写的beforeCommit、beforeCompletion和afterCompletion，这三个方法都会通过TransactionSynchronizationAdapter#isOpen来判断sqlSession是否归零了，并彻底关闭sqlSession。


org.apache.ibatis.session.defaults.DefaultSqlSession内部有着相当丰富的select、insert、update、delete以及rollback、commit等方法
其内部存储了
Executor org.apache.ibatis.session.defaults.DefaultSqlSession.executor
Configuration org.apache.ibatis.session.defaults.DefaultSqlSession.configuration
boolean org.apache.ibatis.session.defaults.DefaultSqlSession.autoCommit

DefaultSqlSession首先会通过内部的configuration获取MappedStatement，而MappedStatement其实就代表XML中的一个SQL，因而其内部的很多实例字段都是SQL中对应的属性。
org.apache.ibatis.mapping.MappedStatement内部的主要字段：
	org.apache.ibatis.mapping.SqlSource——sqlSource，这是一个接口，其有很多实现，比较重要的是StaticSqlSource，RawSqlSource和DynamicSqlSource。
	其中，RawSqlSource和DynamicSqlSource分别对应了静态sql与动态sql，不论是他们之中的哪一种，内部都封装了一个StaticSqlSource对象。

然后以MappedStatement为入参交由executor相关的CRUD操作（其实Executor内部关于CRUD的操作只有query和update）

org.apache.ibatis.executor.Executor——DefaultSqlSession内部其实就是调用了这个实例，来封装JDBC操作的

Executor的实现类很多，主要有：
CachingExecutor
BaseExecutor
BatchExecutor继承自BaseExecutor，对应ExecutorType#BATCH，这个执行器会批量执行所有更新语句
ReuseExecutor继承自BaseExecutor，对应ExecutorType#REUSE，这个执行器类型会复用预处理（statement）语句。
SimpleExecutor继承自BaseExecutor，对应ExecutorType#SIMPLE，这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理（statement）语句。
ClosedExecutor继承自BaseExecutor

ReuseExecutor内部维护了一个Map<String, Statement>类型的statementMap，key为sql，value为Statement，每次执行jdbc操作时，会先从该map中获取Statement。
BatchExecutor
SimpleExecutor

Executor都通过创建StatementHandler来处理statement。
StatementHandler主要有以下实现：
BaseStatementHandler
RoutingStatementHandler
CallableStatementHandler继承自BaseStatementHandler
PreparedStatementHandler继承自BaseStatementHandler
SimpleStatementHandler继承自BaseStatementHandler

其实，早在调用DefaultSqlSessionFactory.openSession()构建sqlSession的时候，就已经通过Configuration#newExecutor(Transaction, ExecutorType)构建了该Executor的ExecutorType，默认为SIMPLE，而从Configuration.newExecutor(Transaction, ExecutorType)中可以看出，如果启用了缓存，即cacheEnabled为true时，不论之前的赋值如何，Executor最终都会被实例化为CachingExecutor对象。

至此，mybatis神秘的面纱已经基本揭开了，此时已经在操作JDBC的相关类了

org.apache.ibatis.scripting.xmltags.SqlNode

org.apache.ibatis.mapping.ResultMap对应xml的resultMap
List<ResultMapping> resultMappings映射字段的集合，org.apache.ibatis.mapping.ResultMapping对应每个映射字段的column、jdbcType、javaType、property以及对应的类型处理器typeHandler等。

DataSourceTransactionManager
事务由#doBegin开启

Environment.getTransactionFactory()可以获取事务工厂TransactionFactory（SpringManagedTransactionFactory、ManagedTransactionFactory、JdbcTransactionFactory）用TransactionFactory可以获取Connection进行数据库操作，其中SpringManagedTransactionFactory生产的SpringManagedTransaction的获取Connection的过程就是通过DataSourceUtils获取的。mybatis-spring默认TransactionFactory为SpringManagedTransactionFactory


/******************************************************************/


RabbitMQ

延时队列
	1、插件方式
	2、TTL Time To Live
		死信交换器 ——> 死信队列 ——> 死信Consumer
		单条消息的过期、队列里面消息的过期时间

顺序消费
	多个生产者发送消息到队列，有多个消费者的时候
	1、一个队列只有一个消费者
	2、MsgID、parentID（批次ID）全局
	生产者：前一条消息未消费，不继续发送消息
	消费者：

消息幂等性
	MsgID、BusinessID 流水 —— 落库



/******************************************************************/




SpringMVC默认对List<Object>的复合泛型集合入参是无法做转换的，若需要以List为入参，可以外部再包一个对象，或以json形式让springmvc读取

/******************************************************************/


NIO
NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。
https://mp.weixin.qq.com/s/c9tkrokcDQR375kiwCeV9w


/******************************************************************/


java、js的浮点精度问题
0.7+0.1=？




关于登录接口
1、后端生成一个用于加密明文的key并控制其生命周期，value为随机数，并用该key存入公钥、私钥，然后将key、公钥返回给前台
2、前端通过js将用户名、密码与key获取的salt（？？）拼装以公钥加密成token，以token和key向后端发送登录请求
	（1）前端以key异步请求后台获取salt
	（2）以salt、用户名、密码组装token，并以token、key发送登录请求
3、后端通过key获取salt、私钥，并以私钥解密token，然后以salt拆分解密后的token获取用户名、密码





ObjectMapper相关配置
com.fasterxml.jackson.databind.ObjectMapper.configure(DeserializationFeature, boolean)
第一个参数为com.fasterxml.jackson.databind.DeserializationFeature枚举类
第二个参数为对应的值




RuntimeBeanReference




Spring默认使用org.apache.commons.logging.LogFactory即apache的common-logging作为日志系统，而slf4j通过重写了一个相同包名、类名的LogFactory实现了由slf4j适配common-logging的过程。


// TODO
1、SpringAOP advisor的原理
2、tx、task、mvc的注解启动深入研究
3、spring事务的深入研究——TransactionAttributeSourceAdvisor
4、@Async原理——
AsyncAnnotationBeanPostProcessor与AsyncAnnotationAdvisor
以TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME即org.springframework.context.annotation.internalAsyncAnnotationProcessor为name注册AsyncAnnotationBeanPostProcessor，其通过实现BeanPostProcessor.postProcessAfterInitialization(Object, String)，也会创建代理对象（仅当方法上有@Async时才会创建代理对象），并以AsyncAnnotationAdvisor为Advisor注入增强逻辑。
ProxyFactory继承自AdvisedSupport，内部可存储一个Advisor集合，并构建带有这些增强Advisor的代理对象。


关于ProxyConfig、AdvisedSupport、ProxyCreatorSupport、ProxyFactory，四者的关系为从后往前为继承
1、ProxyConfig：——https://www.jianshu.com/p/1f8dbeadd79d
（1）proxyTargetClass——true代表直接代理类，false代表代理接口。默认为false
（2）optimize——是否执行某些优化，感觉基本没怎么用到
（3）opaque——代表子类是否能被转换为Advised接口，默认为false，表示可以
（4）exposeProxy——是否暴露代理，也就是是否把当前代理对象绑定到AopContext的ThreadLocal属性currentProxy上去，常用于代理类里面的代理方法需要调用同类里面另外一个代理方法的场景
（5）frozen——当前代理配置是否被冻结，如果被冻结，配置将不能被修改


2、AdvisedSupport：除继承自ProxyConfig之外，还实现了Advised接口，最终被注入AopProxy（jdk或cglib）对象的也是此类型，因而可强转为Advised，此类内部通过methodCache缓存了链接器链，key为MethodCacheKey(Method)，value为拦截器List，以AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice(Method, Class<?>)获取。若获取不到，则继续调用AdvisedSupport.advisorChainFactory，以自身this为入参传入，这样便可通过this即AdvisedSupport#getAdvisors获取自身的Advisor，这样要获取advice也只需要advisor.getAdvice，JdkDynamicAopProxy#invoke就是这么做的，并通过MethodMatchers.matches和ClassFilter#matches对方法进行匹配，以确认是否需要添加当前拦截器（这里的具体逻辑可见JdkDynamicAopProxy.invoke(Object, Method, Object[])）
（1）拥有Advisor集合和Advisor数组即advisors和advisorArray用以存储增强器
（2）有目标对象的targetSource（封装有target的class以及object实例）
（3）有目标对象的父级接口Class集合的interfaces
（4）可通过AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice(Method, Class<?>)获取当前方法的拦截器链，以便在ReflectiveMethodInvocation（JdkDynamicAopProxy）或CglibMethodInvocation（CglibAopProxy）中递归调用。
关于AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice(Method, Class<?>)
其内部以DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(Advised, Method, Class<?>)，通过入参Advised#getAdvisors()获取advisors，然后逐个判断advisor是否为PointcutAdvisor或IntroductionAdvisor的实现，继而调用AdvisorAdapterRegistry.getInterceptors(Advisor)逐个增加拦截器。
	1、通过advisor#getAdvice获取每个advice
	2、将每个advice向下转型为MethodInterceptor，若成功，将其添加到返回的MethodInterceptor数组中
	3、循环DefaultAdvisorAdapterRegistry.adapters（该对象是个AdvisorAdapter集合，内部默认添加三个AdvisorAdapter，分别是方法前置的MethodBeforeAdviceAdapter，方法后置的AfterReturningAdviceAdapter和异常通知器ThrowsAdviceAdapter），通过循环调用每个adapter#supportsAdvice(Advice)，判断该adapter是否支持当前advice，若支持，则也添加到返回的MethodInterceptor数组中。
	4、返回的MethodInterceptor


3、ProxyCreatorSupport：
（1）内部存储了一个AopProxyFactory类型的aopProxyFactory（默认无参构造中为DefaultAopProxyFactory类型，jdk和cglib的代理对象构造都靠该类创建），可用来创建代理对象

4、ProxyFactory：继承自ProxyCreatorSupport，而ProxyCreatorSupport又继承自AdvisedSupport
（1）内部没有什么新增加的变量，内部的方法也都是调用父类的方法
（2）通过调用父类的方法进行设置各种参数
（3）通过调用父类的方法进行创建代理对象


AspectJAwareAdvisorAutoProxyCreator及其子类AnnotationAwareAspectJAutoProxyCreator都继承自ProxyConfig，其创建代理对象也是依赖于ProxyFactory，同时由于其实现的BeanPostProcessor#postProcessAfterInitialization(Object, String)依赖于真实对象，真实对象不能为空，所以这个BeanPostProcessor的优先级会特别低，必须在最后执行才能保证创建代理对象，所以在ProxyProcessorSupport#order中，我们看到了其为Ordered.LOWEST_PRECEDENCE。除此之外，在AbstractAutoProxyCreator#wrapIfNecessary(Object, String, Object)判断是否需要代理时，通过AbstractAutoProxyCreator#getAdvicesAndAdvisorsForBean获取目标对象类的拦截器栈，如果为AbstractAutoProxyCreator.DO_NOT_PROXY即null时，表示不必代理，否则继续创建代理对象。


AOP代理对象执行过程：
JdkDynamicAopProxy：// TODO


Pointcut、Advice、Advisor

Pointcut——即连接点，程序运行中的某个阶段点，比如方法的调用、异常的抛出等
Advice——它是某个连接点所采用的处理逻辑，也就是向连接点注入的代码。例如：输出的日志信息，就是一个Advice
Advisor——它是Pointcut和Advice的配置器，它包括Pointcut和Advice，是将Advice注入程序中Pointcut位置的代码


Advisor——可获取Advice
PointcutAdvisor——可获取Pointcut
AbstractPointcutAdvisor——实现了order，默认优先级为Ordered.LOWEST_PRECEDENCE
AbstractGenericPointcutAdvisor——可设置Advice
DefaultPointcutAdvisor——可设置Advice和Pointcut，默认Pointcut为Pointcut.TRUE即TruePointcut.INSTANCE

PointcutAdvisor
IntroductionAdvisor

在AbstractAutoProxyCreator.wrapIfNecessary(Object, String, Object)对是否为aop对象的判断中，是调用AbstractAutoProxyCreator.getAdvicesAndAdvisorsForBean(Class<?>, String, TargetSource)，继而调用findEligibleAdvisors，然后分两步判断的：
1、findCandidateAdvisors——
	（1）调用子类的AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors()
	1、其本质就是从beanFactory中获取所有Adisor的实现bean
	2、BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors()，从beanFactory中获取所有Object的bean，然后调用AspectJAdvisorFactory.isAspect(Class<?>)判断beanType是否有@Aspect的注解，并且beanType内的所有field均不以AbstractAspectJAdvisorFactory.AJC_MAGIC即"ajc$"开头的bean，并调用ReflectiveAspectJAdvisorFactory.getAdvisors(MetadataAwareAspectInstanceFactory)将其封装成Advisor集合添加到Advisor中
2、findAdvisorsThatCanApply——入参是刚刚获取的Advisor实现集合、以及beanClass、beanName，用以判断哪些advisor符合当前beanClass的advisor，并整理出来，其内部实质是调用了AopUtils.findAdvisorsThatCanApply(List<Advisor>, Class<?>)，并逐个以canApply判断（// TODO）
3、extendAdvisors——AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(List<Advisor>)扩展Advisor，主要是调用AspectJProxyUtils.isAspectJAdvice(Advisor)判断是否为AspectJ的Advice，若是则添加ExposeInvocationInterceptor.ADVISOR，并设置到头
4、sortAdvisors——将advisor排序

SpringAOP注解与申明
1、注解：以<tx:annotation-driven/>形式开启事务的模式。transactionManager默认为
2、xml：以<tx:advice>开启注解，仅对特定类的特定方法名实现代理。
	<aop:config>
		<aop:advisor advice-ref="txAdvice" pointcut="execution(* *..*Service.*(..))" />
	</aop:config>
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="save*" propagation="REQUIRED" rollback-for="Exception" />
		</tx:attributes>
	</tx:advice>

proxy-target-class与expose-proxy
proxy-target-class：默认proxy-target-class为false，表示以代理类有接口可实现重写，如果设置为true，则表示以cglib即以继承方式实现代理，同时仅对带有@Transactional修饰方法的类有效，其他类不会以代理形式存在。见AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)
expose-proxy：默认为false，表示不会暴露代理对象，这个属性是为了解决service中自我调用的问题而存在的，若设置为true，表示将代理暴露出来，则事务中该service就会以线程对象的形式被保存起来，自我调用时，只要以AopContext.currentProxy()获取当前线程的代理对象，然后将类型强转即可变相实现了自我调用事务不失效的效果。见AopConfigUtils.forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry)

在AOP代理对象：AdvisedSupport继承自ProxyConfig，内部拥有所有之前设置的一些aop属性，包括proxyTargetClass与exposeProxy，当JdkDynamicAopProxy或CglibAopProxy实例化时，AdvisedSupport会作为入参传递给这两种类的构造，然后以实例变量#advised的形式存储在内部。
在JdkDynamicAopProxy.invoke或CglibAopProxy#intercept即反射调用时根据此AdvisedSupport即advised的exposeProxy是否为true，即是否暴露代理，若暴露，则会将当前代理的proxy以AopContext.setCurrentProxy(Object)的形式保存起来，该方法会返回之前的线程变量，这样在该反射方法执行完毕后，原变量会在finally中被恢复回去。


AOP配置beanPostProcessor
InfrastructureAdvisorAutoProxyCreator、AspectJAwareAdvisorAutoProxyCreator与AnnotationAwareAspectJAutoProxyCreator：同是AbstractAdvisorAutoProxyCreator的子类
InfrastructureAdvisorAutoProxyCreator：事务注解的aop对象的生成
AnnotationAwareAspectJAutoProxyCreator（继承自AspectJAwareAdvisorAutoProxyCreator）：扩展对@Aspect注解的支持，基于@Aspect注解的aop代理对象的生成
AspectJAwareAdvisorAutoProxyCreator：基于配置的aop代理对象的生成
AnnotationAwareAspectJAutoProxyCreator的注册方式：
其baneName为AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME即org.springframework.aop.config.internalAutoProxyCreator，其随后将负责产出各种代理对象，并在中根据proxy-target-class与expose-proxy的值，将其设置给AnnotationAwareAspectJAutoProxyCreator(ProxyConfig)#proxyTargetClass与exposeProxy（默认都为false）

AnnotationAwareAspectJAutoProxyCreator：继承自AspectJAwareAdvisorAutoProxyCreator，在其基础上扩展了对@Aspect注解代理的支持
在<aop:aspectj-autoproxy/>——AspectJAutoProxyBeanDefinitionParser.parse(Element, ParserContext)完成注册

InfrastructureAdvisorAutoProxyCreator
而在<tx:annotation-driven />——且mode="proxy"时，调用AnnotationDrivenBeanDefinitionParser.AopAutoProxyConfigurer.configureAutoProxyCreator，最后会调用AopNamespaceUtils#registerAutoProxyCreatorIfNecessary注册InfrastructureAdvisorAutoProxyCreator

AspectJAwareAdvisorAutoProxyCreator
<aop:config>

xml：TxAdviceBeanDefinitionParser.parseAttributeSource(Element, ParserContext)
// TODO

/***********************************************************************************/
Spring事务

PlatformTransactionManager
TransactionStatus getTransaction(TransactionDefinition definition)——获取事务
void commit(TransactionStatus status)——提交
void rollback(TransactionStatus status)——回滚

AbstractPlatformTransactionManager(PlatformTransactionManager)——抽象事务管理器，下有DataSourceTransactionManager、JtaTransactionManager（各容器自己继承，如WebLogicJtaTransactionManager、WebSphereUowTransactionManager等）等

transactionManage会被注入TransactionInterceptor(TransactionAspectSupport)#transactionManage，由TransactionInterceptor进行统一的事务AOP拦截、控制

AsyncAnnotationAdvisor，其拦截器为AnnotationAsyncExecutionInterceptor
ExposeInvocationInterceptor.ADVISOR（DefaultPointcutAdvisor），其拦截器为ExposeInvocationInterceptor——https://blog.csdn.net/zknxx/article/details/80087623
继承自MethodInterceptor，其ADVISOR为DefaultPointcutAdvisor类型，内部注入了一个ExposeInvocationInterceptor即其本身。其#invoke为绑定当前的MethodInvocation（也可以是ReflectiveMethodInvocation）到线程变量中，以供其他地方调用，可通过ExposeInvocationInterceptor.currentInvocation()获取使用
DefaultBeanFactoryPointcutAdvisor，其拦截器为spring的事务拦截器TransactionInterceptor——继承自TransactionAspectSupport，spring的事务拦截器，#invoke执行事务逻辑，会调用父类TransactionAspectSupport#invokeWithinTransaction

TransactionInterceptor(TransactionAspectSupport)#invokeWithinTransaction分析：
1、通过getTransactionAttributeSource().getTransactionAttribute(method, targetClass)根据目标类型和目标方法从transactionAttributeSource中获取当前事务策略TransactionAttribute，如NameMatchTransactionAttributeSource.getTransactionAttribute(Method, Class<?>)是根据方法名获取事务策略，然后放入缓存map——NameMatchTransactionAttributeSource.nameMap中（// mappedName获取？）
NameMatchTransactionAttributeSource.nameMap中缓存了方法名正则与transactionAttr的对应关系，其初始化在aop:config的解析类TxAdviceBeanDefinitionParser.parseAttributeSource(Element, ParserContext)中。

2、调用TransactionAspectSupport.determineTransactionManager(TransactionAttribute)决定当前的事务管理器

3、TransactionAspectSupport.methodIdentification(Method, Class<?>, TransactionAttribute)根据类名、方法名生成唯一的joinpoint的ID标识——方法的全限定名

4、TransactionAspectSupport.createTransactionIfNecessary(PlatformTransactionManager, TransactionAttribute, String)创建当前事务信息TransactionInfo
	（1）、判断txAttr#getName如果为空，则实例化委派对象DelegatingTransactionAttribute，并传入原txAttr，以及重写getName为全限定名——joinpointIdentification
	（1）、AbstractPlatformTransactionManager.getTransaction(TransactionDefinition)调用内部注入的事务管理器获取事务，通用逻辑定义在AbstractPlatformTransactionManager中
	①该方法首先会调用对应事务管理器的实现——transactionManager#doGetTransaction()获取事务对象，然后通过TransactionSynchronizationManager#getResource(dataSource)获取线程变量ConnectionHolder并设置到TransactionObject中（所以第一次获取ConnectionHolder是空，但新事务标记newConnectionHolder默认为false，稍后会在doBegin中被更改），根据事务的传播性获取TransactionStatus的方法。

	②
		if (isExistingTransaction(transaction)) {
			// Existing transaction found -> check propagation behavior to find out how to behave.
			return handleExistingTransaction(definition, transaction, debugEnabled);
		}
	AbstractPlatformTransactionManager.isExistingTransaction(Object)判断txObject的ConnectionHolder#transactionActive是否为true，即是否为活跃事务（1）如果是第一次创建事务，那么ConnectionHolder#transactionActive默认为false（稍后会在doBegin中，将transactionActive设置为true）；
	（2）如果不是第一次，那么会执行handleExistingTransaction，这个方法会根据事务的传播性执行挂起或创建新事务操作
	// TODO

	②调用配置的事务管理器实现——transactionManager#doBegin开启事务，首先会获取的ConnectionHolder，如果获取不到就调用自行实例化，并且说明当前为一个全新的事务，设置DataSourceTransactionObject#newConnectionHolder为true，并通过内置的dataSource获取Connection设置到其中，之后会判断该事务是否自动提交，并设置成手动提交；再将txObject的ConnectionHolder#transactionActive设置为true，表明事务被激活，（即下一次的getTransaction在DataSourceTransactionManager.isExistingTransaction(Object)将返回true，并根据事务的传播性判断是否要继续创建新的事务）最后将ConnectionHolder保存到DataSourceTransactionObject中；还会判断事务的超时时间等...方法的最后会调用DataSourceTransactionManager.DataSourceTransactionObject.isNewConnectionHolder()判断其是否为一个新的事务，如果是新的，就通过TransactionSynchronizationManager#bindResource以datasource为key，将ConnectionHolder保存到线程变量中。
	注：之后在持久层框架可以通过DataSourceUtils.getConnection(DataSource)获取刚才保存到线程变量中的ConnectionHolder，（若当前线程没有绑定ConnectionHolder，则会通过dataSource重新获取connection并实例化ConnectionHolder并绑定到当前线程中）继而也就能获取Connection了，并且，每条用一次getConnection获取一次连接，会调用ResourceHolderSupport.requested()，即自增1，以便之后判断事务是否结束使用，该类封装了一些dataSource与TransactionSynchronizationManager相关的线程安全方法供持久层框架使用，mybatis就有SpringManagedTransaction.getConnection()就是通过DataSourceUtils获取的连接。
	注：这里有个坑，每次springaop都是先从线程变量TransactionSynchronizationManager中获取连接，获取不到再实例化，因而第一次必然获取不到，然后会手动调用dataSource获取Connection，每次获取之后，dataSource会变，即活跃连接数等会改变，但是依然可以正确获取Connection，说明threadLocal内部保存的也是引用。
	——https://www.cnblogs.com/just4me/p/6428077.html

	③prepareSynchronization，判断DefaultTransactionStatus.isNewSynchronization()，为true，则通过TransactionSynchronizationManager绑定当前事务的DefaultTransactionStatus和TransactionDefinition的许多属性到线程变量中。
	（2）、TransactionAspectSupport.prepareTransactionInfo(PlatformTransactionManager, TransactionAttribute, String, TransactionStatus)，将入参传入并创建TransactionInfo，该方法的最后会通过TransactionAspectSupport.TransactionInfo.bindToThread()将当前TransactionInfo绑定到线程变量中。
	①根据事务管理器、事务策略以及方法的全限定名实例化TransactionInfo(tm, txAttr, joinpointIdentification)TransactionAttribute, String)②调用TransactionAspectSupport.TransactionInfo.bindToThread()将TransactionInfo绑定到线程变量（TransactionAspectSupport#transactionInfoHolder）中。

5、TransactionAspectSupport.InvocationCallback.proceedWithInvocation()当前methodInterceptor主要逻辑执行完毕，继续向下执行的方法（但是此时所有逻辑依然没有出try语句块，之后的反射调用方法逻辑依然还在try中，所以可以做到catch所有异常，springaop就是通过这种方式完成了事务控制）
需要注意的是，如果既使用了事务配置模式，方法上又添加了注解事务时，被事务代理的方法会同时存在两种TransactionInterceptor，并且注解的TransactionInterceptor的执行顺序在配置的TransactionInterceptor之后，即注解事务会在最后被调用，这样前一次配置事务的事务属性在绑定到线程变量后，会在TransactionAspectSupport.InvocationCallback.proceedWithInvocation()中被注解事务特性给覆盖掉线程变量，这样就达到了注解事务的配置优于配置模式的事务的效果了，但是注解驱动配置必须在声明的配置之后才会生效。

6、completeTransactionAfterThrowing，当有异常发生时，调用TransactionAspectSupport.completeTransactionAfterThrowing(TransactionInfo, Throwable)，该方法首先会检查是否开启了事务（？），其次会调用transactionAttribute.rollbackOn(ex)判断TransactionAttribute是否能处理当前抛出的异常，若能处理，调用PlatformTransactionManager.rollback(TransactionStatus)进行回滚，若不能处理，直接commit事务


7、TransactionAspectSupport.cleanupTransactionInfo(TransactionInfo)——将txInfo进行重置工作，让它恢复到前一个状态

8、TransactionAspectSupport.commitTransactionAfterReturning(TransactionInfo)




TransactionAspectSupport.currentTransactionInfo()实际就是通过线程变量TransactionAspectSupport.transactionInfoHolder存储TransactionInfo
TransactionInfo
TransactionAspectSupport.TransactionInfo.bindToThread可以将当前this即TransactionInfo绑定到当前线程，并将保留前一次的线程对象到本地实例变量oldTransactionInfo中，然后可以通过TransactionInfo.restoreThreadLocalStatus将oldTransactionInfo恢复到当前线程变量中。
DefaultTransactionStatus（AbstractTransactionStatus->TransactionStatus），TransactionAspectSupport.currentTransactionStatus()就是获取本地线程变量TransactionInfo，继而获取TransactionInfo.transactionStatus

TransactionInfo
private final PlatformTransactionManager transactionManager;——配置的事务管理器（如DataSourceTransactionManager）
private final TransactionAttribute transactionAttribute;——rollbackOn(ex)可以判断当前事务是否可以为入参的异常回滚
private final String joinpointIdentification;
private TransactionStatus transactionStatus;——事务状态（如DefaultTransactionStatus，DataSourceTransactionManager与DefaultTransactionStatus成对）
private TransactionInfo oldTransactionInfo;

TransactionStatus（）
boolean isNewTransaction();——是否新事务
boolean hasSavepoint();
void setRollbackOnly();——设置是否需要回滚
boolean isRollbackOnly();——是否需要回滚
void flush();
boolean isCompleted();——事务是否完成


DefaultTransactionStatus（AbstractTransactionStatus->TransactionStatus）
Object transaction;——DataSourceTransactionObject
boolean newTransaction;是否为新事务
boolean newSynchronization;是否同步
boolean readOnly;是否只读
boolean debug;是否调试
Object suspendedResources;

TransactionDefinition——定义了事务的隔离、传播级别、是否只读、超时时间以及名称
TransactionAttribute——继承自TransactionDefinition，增加了一个判断是否支持回滚的rollbackOn(ex)和getQualifier()（// TODO）

RuleBasedTransactionAttribute（DefaultTransactionAttribute->DefaultTransactionDefinition并实现TransactionDefinition、TransactionAttribute）
spring默认的策略在DefaultTransactionAttribute.rollbackOn(Throwable)中，只为运行时异常和Error回滚


DataSourceTransactionManager继承自AbstractPlatformTransactionManager，AbstractPlatformTransactionManager中设置了很多常量和事务的一些默认策略和超时时间等等。


DataSourceTransactionObject（JdbcTransactionObjectSupport->实现SmartTransactionObject）
内部存储ConnectionHolder，ConnectionHolder内部存储Connection
ConnectionHolder（ResourceHolderSupport->ResourceHolder）
TransactionSynchronizationManager——存储一堆的threadLocal
	private static final ThreadLocal<Map<Object, Object>> resources =
			new NamedThreadLocal<Map<Object, Object>>("Transactional resources");
	private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =
			new NamedThreadLocal<Set<TransactionSynchronization>>("Transaction synchronizations");
	private static final ThreadLocal<String> currentTransactionName =
			new NamedThreadLocal<String>("Current transaction name");
	private static final ThreadLocal<Boolean> currentTransactionReadOnly =
			new NamedThreadLocal<Boolean>("Current transaction read-only status");
	private static final ThreadLocal<Integer> currentTransactionIsolationLevel =
			new NamedThreadLocal<Integer>("Current transaction isolation level");
	private static final ThreadLocal<Boolean> actualTransactionActive =
			new NamedThreadLocal<Boolean>("Actual transaction active");

DataSourceTransactionManager继承自AbstractPlatformTransactionManager

TransactionInterceptor的注册方式：
1、<tx:advice>——通过AbstractSingleBeanDefinitionParser.parseInternal调用重写的TxAdviceBeanDefinitionParser#getBeanClass获取TransactionInterceptor
2、<tx:annotation-driven/>——AnnotationDrivenBeanDefinitionParser.AopAutoProxyConfigurer.configureAutoProxyCreator(Element, ParserContext)



AnnotationTransactionAttributeSource
BeanFactoryTransactionAttributeSourceAdvisor
// TODO

MethodInterceptor、MethodInvocation
MethodInterceptor(Interceptor->Advice)，方法拦截器，执行反射逻辑
MethodInvocation(Invocation->Joinpoint)，可获取需要代理的方法（MethodInvocation#getMethod）、参数（Invocation#getArguments）
ReflectiveMethodInvocation继承自MethodInvocation


MethodInterceptor
ExposeInvocationInterceptor
TransactionInterceptor // TODO


org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0
org.springframework.transaction.config.internalTransactionAdvisor

org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* *..*Service.*(..))]; advice bean 'txAdvice'

org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor: advice bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'

InstantiationModelAwarePointcutAdvisor: expression [insertPointCut()]; advice method [public void com.got.ticket.web.base.advice.TicketAdvice.beforeInsert(org.aspectj.lang.JoinPoint)]; perClauseKind=SINGLETON

InstantiationModelAwarePointcutAdvisor: expression [updatePointCut()]; advice method [public void com.got.ticket.web.base.advice.TicketAdvice.beforeUpdate(org.aspectj.lang.JoinPoint)]; perClauseKind=SINGLETON]


/*******************************************************************************************/


关于@Autowired和@Value
// TODO 与 AbstractBeanFactory.embeddedValueResolvers有关
AbstractApplicationContext在初始化的时候会调用AbstractBeanFactory判断内部的embeddedValueResolvers即StringValueResolver是否为空，为空就会添加一个内部的resolver，因而子容器在初始化的时候如果没有指定StringValueResolver，则@Value注解就会获取不到resolver，就无法完成参数注入，而只有配置了PlaceholderConfigurerSupport.doProcessProperties(ConfigurableListableBeanFactory, StringValueResolver)，其会在内部获取beanFactory并加入到AbstractBeanFactory#embeddedValueResolvers中，即可完成参数注入。
PropertyPlaceholderConfigurer与PropertySourcesPlaceholderConfigurer
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject)
AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject(Object, String, PropertyValues)
DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter)
org.springframework.beans.factory.support.AbstractBeanFactory.resolveEmbeddedValue(String)
org.springframework.util.StringValueResolver.resolveStringValue(String)——PlaceholderResolvingStringValueResolver
org.springframework.util.PropertyPlaceholderHelper.parseStringValue(String, PlaceholderResolver, Set<String>)


AbstractAutowireCapableBeanFactory.doCreateBean(String, RootBeanDefinition, Object[])
MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String)逐个创建InjectionMetadata并放入缓存map——injectionMetadataCache中；
然后在AbstractAutowireCapableBeanFactory#populateBean(String, RootBeanDefinition, BeanWrapper)中逐个调用InstantiationAwareBeanPostProcessor#postProcessPropertyValues逐个将InjectionMetadata下的InjectedElement注入

MergedBeanDefinitionPostProcessor(AutowiredAnnotationBeanPostProcessor或CommonAnnotationBeanPostProcessor)#postProcessMergedBeanDefinition
findAutowiringMetadata——先从injectionMetadataCache中获取，获取不到就调用buildAutowiringMetadata或buildResourceMetadata以InjectionMetadata(Class<?>, Collection<InjectedElement>)构建InjectionMetadata（class为目标类型，collection为需要注入的内部实例），然后放入InjectionMetadata。

InjectionMetadata——即注入元数据


InstantiationAwareBeanPostProcessor(AutowiredAnnotationBeanPostProcessor或CommonAnnotationBeanPostProcessor)#postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String)，
调用CommonAnnotationBeanPostProcessor.findResourceMetadata(String, Class<?>, PropertyValues)通过对应的beanName、beanClass获取InjectionMetadata，InjectionMetadata内部的injectedElements封装了当前bean所有的InjectedElement，然后调用InjectionMetadata.inject(Object, String, PropertyValues)，以循环的方式依次调用对应的InjectedElement#inject，将所有的依赖bean注入。

AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class<?>)——@Autowired、@Value、@Injected
													构建方式：InjectionMetadata(Class<?> targetClass, Collection<InjectedElement> elements
CommonAnnotationBeanPostProcessor.buildResourceMetadata(Class<?>)——@Resource
两者内部都封装有Map<String, InjectionMetadata> injectionMetadataCache，build过程为在do-while循环内以ReflectionUtils.doWithLocalFields(Class<?>, FieldCallback)或ReflectionUtils.doWithLocalMethods(Class<?>, MethodCallback)从目标类中获取所有field，然后逐个判断（静态属性不会注入）并封装添加到InjectionMetadata中，然后继续获取targetClass = targetClass.getSuperclass()即父类，若superClass不为null且不为Object继续循环，直到无父类或为Object。

类似的还有
InitDestroyAnnotationBeanPostProcessor（CommonAnnotationBeanPostProcessor）.findLifecycleMetadata以beanClass从缓存中获取，获取不到调用InitDestroyAnnotationBeanPostProcessor（CommonAnnotationBeanPostProcessor）.buildLifecycleMetadata(Class<?>)构造，构造过程同上，不同的只是返回的是InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata.LifecycleMetadata(Class<?>, Collection<LifecycleElement>, Collection<LifecycleElement>)，将initMethods、destroyMethods分开存储在LifecycleMetadata内部。
其初始化方法postProcessBeforeInitialization执行时机在BeanPostProcessor#postProcessBeforeInitialization中，
其销毁方法postProcessBeforeDestruction执行时机在DisposableBeanAdapter.destroy()中

其中，
InitDestroyAnnotationBeanPostProcessor.initAnnotationType为@PostConstruct
InitDestroyAnnotationBeanPostProcessor.destroyAnnotationType@PreDestroy

InjectedElement

ResourceElement（LookupElement->InjectionMetadata.InjectedElement）
AutowiredFieldElement（InjectionMetadata.InjectedElement）
AutowiredMethodElement（InjectionMetadata.InjectedElement）

DependencyDescriptor

AutowiredFieldElement#inject
1、初始cached为false，表示没有缓存，根据入参field以及required（@Autowired）构建DependencyDescriptor
2、调用beanFactory#resolveDependency，
	1、调用初始化DependencyDescriptor.initParameterNameDiscovery(ParameterNameDiscoverer)
	其内部是先获取AbstractAutowireCapableBeanFactory.parameterNameDiscoverer默认为DefaultParameterNameDiscoverer，然后将其做为入参传入DependencyDescriptor.initParameterNameDiscovery(ParameterNameDiscoverer)
	（1）以javaUtilOptionalClass即java.util.Optional是否等于descriptor.getDependencyType()，构建OptionalDependencyFactory.OptionalDependencyFactory()并调用OptionalDependencyFactory.createOptionalDependency(DependencyDescriptor, String, Object...)返回结果
	（2）ObjectFactory.class或ObjectProvider.class是否等于descriptor.getDependencyType()，返回DependencyObjectProvider.DependencyObjectProvider(DependencyDescriptor, String)
	（3）以javaxInjectProviderClassjavax.inject.Provider是否等于descriptor.getDependencyType()，创建Jsr330ProviderFactory.Jsr330ProviderFactory()并调用Jsr330ProviderFactory.createDependencyProvider(DependencyDescriptor, String)返回结果
	（4）调用DefaultListableBeanFactory.getAutowireCandidateResolver()获取autowireCandidateResolver，一般而言，若容器是使用DefaultListableBeanFactory，那么该autowireCandidateResolver就是SimpleAutowireCandidateResolver类型，然后调用AutowireCandidateResolver.getLazyResolutionProxyIfNecessary(DependencyDescriptor, String)，该方法其实是被写死了null，就是必然返回null。
	所以这里（4）必然会调用DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter)继续解决依赖
		（1）调用DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor)
			1、首先，BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class<?>, boolean, boolean该方法会以beanClass，从beanFactory以及父beanFactory中获取beanName（这就是为什么@Autowired、@Injected、@Value都是以type进行匹配获取bean的）
			2、从DefaultListableBeanFactory.resolvableDependencies中获取keySet()即autowiringType，逐个获取value——autowiringValue，调用AutowireUtils.resolveAutowiringValue(Object, Class<?>)逐个判断autowiringValue是否非requiredType的实例，且autowiringValue是否实现了ObjectFactory，等等，符合之后将autowiringValue转化为ObjectFactory，并以ObjectFactory#getObject返回bean实例，如ServletRequest、ServletResponse、HttpSession、WebRequest就是以ObjectFactory形式构建的。
			一般的bean在这里都无法获取实例。
			2、通过DefaultListableBeanFactory.addCandidateEntry(Map<String, Object>, String, DependencyDescriptor, Class<?>)，其内部通过判断入参candidateName在容器内是否存在该单例（一般的bean第一次加载都不会存在，都为（2）的情况）
				（1）若存在，则调用DependencyDescriptor.resolveCandidate获取bean（内部就是调用BeanFactory.getBean(String, Class<?>)获取bean）
				（2）否则调用AbstractBeanFactory.getType(String)获取beanClass，之后会调用getBean(Class<?> clz)获取bean
				不论是（1）、（2）最终都会将bean以key-beanName，value-bean实例或beanClass的形式存入candidates中，并返回
			获取到bean后，findAutowireCandidates方法结束，返回Map<String, Object> matchingBeans-key为beanName，value为beanClass或bean实例
			3、// TODO
		（2）若findAutowireCandidates返回的matchingBeans为空即一个匹配的bean都没有，则调用DefaultListableBeanFactory.raiseNoMatchingBeanFound(Class<?>, ResolvableType, DependencyDescriptor)抛出NoSuchBeanDefinitionException，若匹配bean不止一个，且之前构造的DependencyDescriptor#required为true即为必须的，且DefaultListableBeanFactory.indicatesMultipleBeans(Class<?>)返回为false即type不是数组或（接口或集合或Map），调用DependencyDescriptor.resolveNotUnique(Class<?>, Map<String, Object>)抛出NoUniqueBeanDefinitionException。
		（3）根据返回的instanceCandidate是否是Object，如果是表示已经是实例，否则根据autowiredBeanName、beanClass调用DependencyDescriptor.resolveCandidate(String, Class<?>, BeanFactory)（其内部也是直接以beanFactory.getBean获取bean实例）获取bean实例并返回。
3、通过AutowiredAnnotationBeanPostProcessor.registerDependentBeans(String, Set<String>)将目标bean与需要注入目标bean的beanName集合通过DefaultListableBeanFactory(DefaultSingletonBeanRegistry)#registerDependentBean(String, String)保存到内部的DefaultSingletonBeanRegistry#dependentBeanMap中，然后设置cached为true。
4、方法的最后判断注入的value是否为空，不为空则通过ReflectionUtils.makeAccessible(Field)设置field的访问权限，然后field.set(bean, value)完成注入

ResourceElement#inject
该方法定义在父类InjectedElement中，根据target是field还是method，直接粗暴的调用ReflectionUtils.makeAccessible(Field)，然后field.set或method.invoke
1、field.set(target, getResourceToInject(target, requestingBeanName));或method.invoke(target, getResourceToInject(target, requestingBeanName));
	（1）getResourceToInject(target, requestingBeanName)
	其中getResourceToInject是ResourceElement内部重写的方法，该方法会根据构建的ResourceElement是否为lazyLookup，若懒加载则调用CommonAnnotationBeanPostProcessor.buildLazyResourceProxy(LookupElement, String)构建代理(???)，否则调用CommonAnnotationBeanPostProcessor.getResource(LookupElement, String)获取bean，该方法首先会以jndiFactory获取bean，获取不到则调用CommonAnnotationBeanPostProcessor.autowireResource(BeanFactory, LookupElement, String)继续获取bean
		CommonAnnotationBeanPostProcessor.buildLazyResourceProxy(LookupElement, String)
		CommonAnnotationBeanPostProcessor.getResource(LookupElement, String)
			CommonAnnotationBeanPostProcessor.autowireResource(BeanFactory, LookupElement, String)
			该方法会判断isDefaultName即默认名称是否存在，且beanFactory是否包含该bean
			1、符合调用AutowireCapableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter)
			2、不符合调用BeanFactory.getBean(String, Class<?>)
			3、方法的最后调用ConfigurableBeanFactory.registerDependentBean(String, String)（实为DefaultSingletonBeanRegistry）
			// TODO


Introspector#decapitalize用于根据属性名转化为对应的方法


/*******************************************************************************************/


Spring循环依赖

该问题发生在getBean的时候

在AbstractBeanFactory.doGetBean的时候
	1、首先调用DefaultSingletonBeanRegistry.getSingleton(String)先从缓存中获取单例bean，该方法首先从singletonObjects一级缓存中获取，若没有获取到，且该bean正在创建中（调用isSingletonCurrentlyInCreation(String beanName)，该方法使用过一个Set<String>保存正在创建中的beanName，创建完成即移除），则会进入二级缓存earlySingletonObjects中获取，若依然获取依然为空且允许提前引用，即入参allowEarlyReference为true时，则会从三级缓存singletonFactories中获取以该beanName为key的value——objectFactory，若获取到了，则调用ObjectFactory.getObject()构建对象，构建完毕后将bean从三级缓存singletonFactories中移除，并放入二级缓存earlySingletonObjects中。
	2、若是第一次getBean，那么上述方法获取一定为空，则会进入DefaultSingletonBeanRegistry.getSingleton(String, ObjectFactory<?>)这个是getSingleton的另一个重载，依然是先从一级缓存singletonObjects中获取bean，不同的是，当获取bean为空时，会调用DefaultSingletonBeanRegistry.beforeSingletonCreation(String beanName)将该bean放入inCreationCheckExclusions中，表示当前bean正在创建中。然后定义newSingleton为false，表示非新的单例，之后会调用ObjectFactory.getObject()，该方法会调用之前在doGetBean中被实现的createBean，也就是AbstractBeanFactory.createBean(String, RootBeanDefinition, Object[])
	该方法中继续调用子类AbstractAutowireCapableBeanFactory.doCreateBean(String, RootBeanDefinition, Object[])，该方法执行完毕后，会将newSingleton改为true
		1、首先会调用AbstractAutowireCapableBeanFactory.createBeanInstance(String, RootBeanDefinition, Object[])创建bean实例（半成品）
		2、执行AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors
		3、判断bean是否为单例、且isSingletonCurrentlyInCreation为true即当前正在创建该bean，且allowCircularReferences是否为true即是否允许循环引用（默认为true），若都符合，表明当前bean正在创建中，会调用DefaultSingletonBeanRegistry.addSingletonFactory(String, ObjectFactory<?>)，该方法会往singletonFactories中添加一个匿名ObjectFactory，其getObject方法为调用AbstractAutowireCapableBeanFactory.getEarlyBeanReference(String, RootBeanDefinition, Object)即获取一个早期引用（只是实例化完成，但内部变量未填充完毕，同时将beanName加入到earlyProxyReferences中，代表该bean已被早期代理引用，这样在之后AbstractAutoProxyCreator.postProcessAfterInitialization(Object, String)中，由于earlyProxyReferences中已包含的bean将不会继续执行wrapIfNecessary获取代理对象了）这样一来，即使当前bean未初始化完成，当其他bean依赖当前bean的时候，调用doGetBean获取bean的时候，在第一个DefaultSingletonBeanRegistry.getSingleton(String)时，singletonObjects、earlySingletonObjects中获取不到bean，也能从singletonFactories中获取到以AbstractAutowireCapableBeanFactory.getEarlyBeanReference实现的objectFactory，也就能获取到一个半成品bean了。
		4、调用AbstractAutowireCapableBeanFactory.populateBean(String, RootBeanDefinition, BeanWrapper)填充bean，若刚才实例化的bean为半成品，则最终也会在这里被加工成成品。
		5、AbstractAutowireCapableBeanFactory.initializeBean(String, Object, RootBeanDefinition)——略
		6、DefaultSingletonBeanRegistry.getSingleton(String, boolean)，其中第二个参数allowEarlyReference为false即不允许早期引用
		7、AbstractBeanFactory.registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition)
		8、方法的最后会根据newSingleton是否为true，若为true即调用DefaultSingletonBeanRegistry.addSingleton(String, Object)注册bean，具体方法为，将bean从earlySingletonObjects、singletonFactories中移除，并添加到singletonObjects中。

SmartInstantiationAwareBeanPostProcessor


ClassPathBeanDefinitionScanner.doScan(String...)
1、调用ClassPathScanningCandidateComponentProvider.findCandidateComponents(String)获取所有被修饰的BeanDefinition，该方法会该basePackage路径上所有符合目前注解过滤器的类统一封装成ScannedGenericBeanDefinition（即扫描的bd
）返回。
2、调用内部的beanNameGenerator——AnnotationBeanNameGenerator.generateBeanName(BeanDefinition, BeanDefinitionRegistry)，其会调用ClassUtils.getShortName(String)获取类名的简称，然后调用Introspector.decapitalize(String)将首字母小写，返回的名称将作为该bean的beanName保存到SimpleBeanDefinitionRegistry.beanDefinitionMap中

几种BeanNameGenerator：
1、DefaultBeanNameGenerator：一般的xml配置bean命名器，一般若没有指定id，name，则会以类的全限定名+"#"+index命名bean。
2、AnnotationBeanNameGenerator：基于注解的bean命名器，一般若没有指定name，则以类的简单名称，并首字母小写命名bean。（内部以ClassUtils.getShortName(String)获取bean的shortClassName，再以java.beans.Introspector.decapitalize(String)将首字母小写）
3、RepositoryBeanNameGenerator：

/*******************************************************************************************/

org.springframework.beans.factory.config.BeanDefinitionVisitor#resolveValue(Object)



Resource——统一继承自org.springframework.core.io.AbstractResource
ClassPathResource与FileSystemResource关系类似ClassPathXmlApplicationContext与FileSystemXmlApplicationContext

Spring核心包依赖关系
spring-core——spring核心包（Resource、Order、Ordered、ClassUtils）
spring-beans依赖spring-core（BeanFactory、InitializingBean、AbstractAutowireCapableBeanFactory）
spring-aop依赖spring-core、spring-beans（spring-aop：ProxyConfig、Advisor、Pointcut; aopalliance：MethodInterceptor、MethodInvocation）
spring-context依赖spring-core、spring-beans、spring-aop、spring-expression（ApplicationContext）
spring-web依赖spring-context（ContextLoader）
spring-webmvc依赖spring-web（DispatcherServlet）


...
1、mybatis深入研究
2、sql原理以及优化
3、



