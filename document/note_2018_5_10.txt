redisCallback
profile――自定义标签<env>――${env}.properties――resources――filter
@Valid――参照JSR-303、JSR-349规范
@GetMapping――spring4.3开始新增的注解，相当于@RequestMapping(method = RequestMethod.GET)
public方法的重写
@Resource――javax的规范，用于按名称注入
RestTemplate――封装了一些HttpClient的方法
aspectj

工具类
google guava――https://www.cnblogs.com/SummerinShire/p/6054983.html
apache common lang3


淘宝前后端分离解决方案――http://2014.jsconf.cn/slides/herman-taobaoweb/index.html

http://blog.csdn.net/jinbiao520/article/details/9903193

vue快速入门
https://www.cnblogs.com/rik28/p/6024425.html
http://www.jb51.net/article/111658.htm

坑――http://www.iteye.com/topic/1131191



conversionService――FormattingConversionServiceFactoryBean――Converter

namespacehandler学以致用――http://blog.csdn.net/boneix/article/details/73608573

mvvm――https://www.jianshu.com/p/a5f2b2b45618

jackson注解――http://blog.csdn.net/sdyy321/article/details/40298081

javax.validator――group――自定义消息――http://jinnianshilongnian.iteye.com/blog/1733708?page=3


springxml解析

spring入口类ContextLoader#initWebApplicationContext――调用本类#configureAndRefreshWebApplicationContext――调用子类AbstractApplicationContext#refresh――调用本类AbstractApplicationContext#obtainFreshBeanFactory――调用子类AbstractRefreshableApplicationContext#refreshBeanFactory――调用子类XmlWebApplicationContext#loadBeanDefinitions，调用AbstractBeanDefinitionReader#loadBeanDefinitions――调用本类#loadBeanDefinitions――调用本类#loadBeanDefinitions――调用子类XmlBeanDefinitionReader#loadBeanDefinitions――调用本类#loadBeanDefinitions――调用本类#doLoadBeanDefinitions――调用本类#registerBeanDefinitions――调用DefaultBeanDefinitionDocumentReader#registerBeanDefinitions――调用本类#doRegisterBeanDefinitions――调用本类#parseBeanDefinitions，至此正式开始解析每个节点，若为bean标签则调用本类#parseDefaultElement解析，若为其他标签则调用BeanDefinitionParserDelegate#parseCustomElement进行自定义标签的解析，见下文。

BeanDefinitionParserDelegate――解析bean的namespace uri，#parseCustomElement会获取所有xml定义的elementNode并以此获取namespaceUri，若namespaceUri为bean则调用#parseDefaultElement，这个方法最终会调用本类的#parseBeanDefinitionAttributes方法，将该bean标签解析完成，其他则调用#parseCustomElement，然后获取该namespaceUri对应的处理器NamespaceHandler，并调用该对象的parse进行相关配置的初始化NamespaceHandler#init
BeanDefinitionParser――bean namespace的各个子参数解析接口，所有解析器最终都会实现这个接口
NamespaceHandler――命名空间注册处理顶级接口
NamespaceHandlerSupport――实现了NamespaceHandler，同时是各种需要注册的namespace的父类，内部封装了一些通用的逻辑，每个NamespaceHandlerSupport的子类会实现NamespaceHandler的init，注册各个element以及对应的解析类，其实质是调用父类NamespaceHandlerSupport的#registerBeanDefinitionParser将element以string、class的形式保存到其内部的map中。
XmlBeanDefinitionReader――xml配置文件的读取器，#doLoadBeanDefinitions，从Resource中解析出w3c的Document对象，用于之后让每个BeanDefinitionParser进行解析
BeanDefinitionDocumentReader――DefaultBeanDefinitionDocumentReader的接口类
DefaultBeanDefinitionDocumentReader――BeanDefinitionDocumentReader的实现类，#registerBeanDefinitions先取得根节点，即XML文件中的<beans>标签，#parseBeanDefinitions用于从根节点开始逐层解析每个标签
同时，ContextLoader#configureAndRefreshWebApplicationContext会调用子类XmlWebApplicationContext的setConfigLocation将contextParam的contextConfigLocation的配置信息注入到location中。
ComponentScanBeanDefinitionParser#parse调用#configureScanner，首先根据是否有use-default-filters属性（默认为true，即会扫描所有带@Component的类），然后调用#createScanner，根据use-default-filters属性判断是否创建注解扫描器（即将@Component添加到includeFilters），然后调用#parseBeanNameGenerator生成bean命名规范器以此进行bean的命名规范控制，最后调用#parseTypeFilters来添加或排除注解类，主要分为两种，include-filter对应includeFilters即需要扫描的注解，exclude-filter对应excludeFilters即需要排除的注解，若要使其生效必须将默认的use-default-filters改为false，即不启用默认配置。根据配置的规则创建了扫描器后，将会用该扫描器#doScan扫描basePackages，调用#findCandidateComponents将basePackages转化为spring可以识别的路径并以set集合的形式读取出来，然后以includeFilters以及excludeFilters进行扫描并调用#registerComponents进行注册，到此整个<context:component-scan/>注解处理完成。

RequestMappingHandlerAdapter――请求映射处理适配器
#afterPropertiesSet，调用#initControllerAdviceCache，用于获取带有ControllerAdvice注解的类，并注册@ModelAttribute以及@InitBinder，用于增强控制器。
#handleInternal，使用模板模式，由父类AbstractHandlerMethodAdapter#handle调用，用于获取请求映射的实体控制器以及具体的方法并执行获取返回值

RequestMapping(http://blog.csdn.net/j080624/article/details/56278461)
RequestMappingHandlerMapping――请求映射处理映射器
#afterPropertiesSet，用于注册绑定每个请求与控制器及方法的关系，该方法会调用父类AbstractHandlerMethodMapping#afterPropertiesSet#initHandlerMethods，扫描mvc容器获取所有bean，然后判断bean是否有@Controller或@RequestMapping注解，若有则迭代该控制器的所有方法，通过MethodIntrospector#selectMethods使用匿名内部类的方式重写MetadataLookup#getMappingForMethod，该方法通过RequestMappingInfo拼接url，最后调用#registerHandlerMethod依次注册方法、url并互相绑定

springmvc――数据绑定――https://www.jianshu.com/p/b2fff5864b11
PropertyEditor――PropertyEditorSupport――属性编辑器
TypeConverter――TypeConverterSupport――类型转换器――TypeConverterDelegate（类型转换委托类――负责具体执行转换的类）
PropertyEditorRegistry――PropertyEditorRegistrySupport――属性编辑注册器

springmvc――数据绑定――https://www.jianshu.com/p/b2fff5864b11
PropertyEditor――属性编辑器的顶级接口
PropertyEditorSupport――属性编辑器支持类，实现了PropertyEditor，封装了通用逻辑，是各个编辑器的父类
PropertyEditorRegistry――属性编辑器注册接口
PropertyEditorRegistrySupport――属性编辑器注册类，实现了PropertyEditorRegistry，封装了通用逻辑，#createDefaultEditors注册了常用类型的属性编辑器，#getDefaultEditor根据类名获取每个类型的默认属性编辑器
TypeConverterSupport――继承自PropertyEditorRegistrySupport，并实现了TypeConverter，用于支持各种对象之间的类型转换，#typeConverterDelegate（TypeConverterDelegate类型转换委托类――负责具体执行转换的类）

PropertyAccessor――属性入口类
AbstractPropertyAccessor――继承自TypeConverterSupport，又实现了PropertyAccessor，可以进行类型转换，也可以将值注入到对应的属性中，#setPropertyValues迭代propertyValues，将每个PropertyValue注入到对应的属性中。

DataBinder――实现PropertyEditorRegistry、TypeConverter的类。支持类型转换，参数验证，数据绑定等功能。
WebDataBinder――DataBinder的子类，主要是针对Web请求的数据绑定，通过AbstractPropertyAccessor
ServletRequestDataBinder――WebDataBinder的子类，由此类完成进行参数绑定，#bind调用父类WebDataBinder#doBind方法，而WebDataBinder将继续调用父类DataBinder#doBind将参数进行绑定

ModelAttributeMethodProcessor――将参数以java对象的形式传入controller的类，是最基本的参数绑定处理器


springmvc自定义数据绑定处理――由PropertyEditorRegistrySupport完成默认的数据绑定器――http://blog.csdn.net/z69183787/article/details/52261289

springmvc参数绑定――http://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html
RequestMappingHandlerAdapter
#getDefaultArgumentResolvers注册默认的参数解析器
#getDefaultReturnValueHandlers注册默认的返回值处理器
RequestResponseBodyMethodProcessor――@RequestBody、@ResponseBody
ServletModelAttributeMethodProcessor――支持对象属性绑定
RequestParamMethodArgumentResolver――@RequestParam――支持简单类型数据绑定
PathVariableMethodArgumentResolver――@PathVariable

SpringMVC消息转换机制
HttpMessageConverter――消息处理顶级接口所有的消息处理器最终都会直接或间接实现这个接口

HttpInputMessage――消息输入处理接口
HttpOutputMessage――消息输出处理接口
HandlerMethodArgumentResolver――方法参数处理接口――用于将入参绑定到java对象
HandlerMethodReturnValueHandler――返回值处理接口――用于将返回值（java对象）输出到前台
如RequestResponseBodyMethodProcessor即实现了HandlerMethodArgumentResolver，又实现了HandlerMethodReturnValueHandler，即既可以处理@RequestBody的请求（#resolveArgument），又可以处理@ResponseBody的返回值（#handleReturnValue）

HandlerExceptionResolver――异常处理接口――用于处理全局异常


DispatcherServlet

initStrategies――DispatcherServlet初始化方法，由方法名可知用于初始化servlet的策略，粗略可以理解为由其爷爷类HttpServletBean#init调用，然后经其父类FrameworkServlet#initServletBean调用
initHandlerMappings――初始化HandlerMapping（如RequestMappingHandlerMapping）
initHandlerAdapters――初始化HandlerAdapter（如RequestMappingHandlerAdapter）


doDispatcher
#getHandlerAdapter根据HandlerExecutionChain的处理器获取能处理的HandlerAdapter（内部通过#supports方法返回的boolean决定能否处理），然后用获取到的HandlerAdapter#handler进行处理，需要注意的是handler只是一个抽象方法，通常实现类为AbstractHandlerMethodAdapter，其实际上是通过调用内部#handleInternal方法进行处理，而此类的handleInternal也只是个接口，需要调用其子类的RequestMappingHandlerAdapter#handleInternal进行处理，然后调用#invokeHandlerMethod进行参数处理、数据绑定、反射调用controller获取返回值并返回等。具体处理为调用ServletInvocableHandlerMethod#invokeAndHandle进行反射调用，其内部有#invokeForRequest以及HandlerMethodReturnValueHandlerComposite#handleReturnValue两个方法比较重要。具体处理如下。

https://my.oschina.net/lichhao/blog/172562
ServletInvocableHandlerMethod#invokeAndHandle调用两个方法：
invokeForRequest先通过适配器获取处理的controller，然后反射调用controller的方法，获取返回值
	其中#getMethodArgumentValues获取参数列表并绑定到java对象，#doInvoke反射执行controller方法获取返回值
handleReturnValue调用HandlerMethodReturnValueHandlerComposite#handleReturnValue根据controller的返回值以及返回值类型决定具体处理的处理器，然后将返回值写入，若处理器为RequestResponseBodyMethodProcessor，则消息转换过程如下。

springmvc messageConverter――
AnnotationDrivenBeanDefinitionParser#parse调用#getMessageConverters，该方法根据你classpath中存在的jar决定最终需要加载哪些messageConverter，然后根据客户端的accept、服务端的produces（由已注册的消息转换器的canWrite决定）决定当前请求的mediaType，然后循环迭代所有消息转换器判断canWrite决定由哪个messageConverter进行消息转换，最后由该消息转换器调用write方法输出（其中每个消息转换器在初始化的时候都会调用构造方法将自身可以处理的mediaType存入了自身的supportedMediaTypes中，以便在之后的produces的判断中能直接从其自身中获取并添加到局部变量中）――http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html

hibernate-validate注解原理
ServletInvocableHandlerMethod#invokeAndHandle――InvocableHandlerMethod#invokeForRequest #getMethodArgumentValues――HandlerMethodArgumentResolverComposite#resolveArgument――ModelAttributeMethodProcessor#validateIfApplicable

InitializingBean――接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。

AbstractAutowireCapableBeanFactory#invokeInitMethods调用afterPropertiesSet

@EnableWebMvc――以注解形式启用mvc注解，等同于在配置中申明<mvc:annotation-driven/>

post――参数以键值对形式隐藏在requestbody中

fastdfs――https://www.cnblogs.com/Leo_wl/p/6731647.html

slf4j log4j
http://www.importnew.com/7450.html
http://blog.csdn.net/tanga842428/article/details/52924883
http://itindex.net/detail/48502-log-%E6%97%A5%E5%BF%97-%E6%A1%86%E6%9E%B6

logback启动原理――http://blog.csdn.net/MrZhangXL/article/details/68489565
StaticLoggerBinder

tomcat加载过程
http://www.cnblogs.com/xing901022/p/4574961.html


书籍、源码
https://www.cnblogs.com/rainy-shurun/p/6564407.html

netty――dubbo默认的通信组件
https://www.jianshu.com/p/c5068caab217

vue相关
vuex――https://segmentfault.com/a/1190000007516967#articleHeader3

vue项目
知乎――https://www.zhihu.com/question/37984203
音乐搜索播放应用――https://github.com/Sioxas/vue-music/
重构CnodeJS社区――https://github.com/shuiRong/VueCnodeJS

js相关：
真值假值――在JavaScript中，Truthy(真值)指的是在Boolean上下文中转换后的值为真的值。所有值都是真值，除非它们被定义为 falsy (即， 除了false，0，“”，null，undefined和NaN 外)。――https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy

netty学习
https://www.cnblogs.com/azcode/p/6876882.html
http://wiki.jikexueyuan.com/project/netty-4-user-guide/realize-chat.html
https://www.jianshu.com/p/b9f3f6a16911
netty能做什么――https://www.zhihu.com/question/24322387

单独部署一台文件服务器，以避免将来集群部署应用时，文件路径读取的问题。
Load Balance（负载均衡）与High Available（高可用）

部署相关
http://www.importnew.com/27838.html#comment-639983

jenkins
https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000

string
https://www.zhihu.com/question/57697842

es6
https://www.jianshu.com/p/287e0bb867ae

队列
https://www.cnblogs.com/tadckle/p/3530084.html

类加载
https://blog.csdn.net/chenge_j/article/details/72677766

springboot学习
http://springboot.fun/

spring快速构建项目
http://start.spring.io/